#IMPORTANT: to sub variables into a string ---> f"{a}...{b}"
#keep all text font Helvetica for uniformity 
#IMPORTANT: if trying to update labels in a loop, GUI pauses until loop completes so must use root.update() within the loop to force visual change
#cd to directory in which you want the exe to be saved in cmd ----> pyinstaller.exe --onefile -w filename.py
#USE TRY, EXCEPT if anticipating any errors generated by the user
#TO RESIZE IMAGES ON THE GUI, CHECK THE CODE AT THE TOP OF PAGE 2 SECTION

#plot styling: https://matplotlib.org/2.1.2/api/_as_gen/matplotlib.pyplot.plot.html

###MEGA IMPORTANT: GRF FACTOR WAS DETERMINED AS 250/3 times the FSR output for 1BW from experiment, this can be changed given a more in depth experiement for GRF extrapolation from FSR readings
#esentially when balancing whole body weight on one FSR it seems to output 0.012 the amount of BW of the person or 1.2%. so 1 BW/0.012 = 250/3 

#nevermind, voltage divider equation was right, FSR circuit in thesis was wrong and actually designed w 10k pullup resistor instead of pulldown 
    #therefore voltage does drop w applied pressure and bit value mapping and voltage divider math are both right
        #IOW code is still correct so nothing to worry about
        #####THIS COMMENT WAS WRITTEN ON AUGUST 23rd 2022 at 4:15am#####

############################################################################################################################
#SECTION FOR IMPORTING MODULES
from cProfile import label
from telnetlib import GA
from tkinter import *
from tkinter import filedialog
from turtle import left, right
from typing import Counter #library that allows files to be browsed 
from PIL import Image, ImageTk #for adding images to the GUI
import matplotlib.pyplot as plt #maybe wanna just do all matplotlib eventually not sure
import numpy as np
import urllib.request
from tkinter import ttk #this is for adding new tabs/widows to GUI
import pandas as pd #for creating data frames
import csv #FOR WRITING THE DATA
import time #FOR ADDING TIME DELAY STATEMENTS, might be good for adding buffers to serial port readings
import random #this and string module is for generating the random alphanumeric to be tagged to the data set +patient email (is fail safe in case email forgotten)
import string
from serial.serialutil import Timeout
import serial.tools.list_ports #kinda obvious what this is for
import serial
from serial import Serial
from numpy import interp #used in replacement of map function in ard IDE
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
from tkinter import ttk #package for adding progress bar
import threading #TO BE ABLE TO DO PARALLEL PROCESSING, can use for the progress bar to make it smooth while data collection is occuring
#threading.Thread(target = ).start()
from tkinter.messagebox import askyesno
from PIL import ImageSequence #for GIF addition
import os
from datetime import datetime #for adding date time tag onto saved files
from scipy.signal import find_peaks #THIS IS FOR PEAK FINDING TO FIND THE HEEL ON AND TOE OFF EVENTS FROM THE RAW FSR DATA
from scipy import signal #WILL BE USING THIS LIBRARY FOR FILTERING IMU DATA
from fpdf import FPDF #THIS IS FOR GENERATING CLIENT REPORT AT THE END OF THE APPLICATION
from matplotlib.backends.backend_pdf import PdfPages #for scatter plots in generated PDF
from PyPDF2 import PdfMerger #sadly have to merge two pdf's w this library 
##################################################################################################################################



##########################################################################################################################################
#SECTION FOR IMPORTING IMAGES TO BE USED IN THE PROGRAM
image_directory = 'images'

if not os.path.exists(image_directory):
    os.mkdir(image_directory)

decisionicsImage = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/editeddecis_orig.png', "images/decisionics.png")

engineeringImage = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/editiedut_orig.jpg', "images/engineering.png")

torontoLogo = urllib.request.urlretrieve('https://pbs.twimg.com/profile_images/1014942894778650626/NyjWU7Fp_400x400.jpg', "images/UofT.jpg")

gaitFigure = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/published/detoj-removebg-preview.jpg?1638314621', "images/gaitFigure.png")

temporalParametersImage = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/bigone_orig.png', "images/temporalParameters.png")

calibrationGIF = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/ezgif-com-gif-maker-2-1_orig.gif', "images/calibration_GIF.gif")

ON_image = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/use-on_orig.jpg', "images/ON.jpg")

OFF_image = urllib.request.urlretrieve('https://jiminhater.weebly.com/uploads/1/3/9/5/139519377/use-off_orig.jpg', "images/OFF.jpg")
#########################################################################################################################################



###############################################################################################################################
#SECTION FOR DEFINING ROOT GUI CHARACTERISTICS
root = Tk() #creates the root GUI window

#algorithm for setting GUI size to same size as display on clinic computers will be smaller
screenWidth = root.winfo_screenwidth() 
screenHeight = root.winfo_screenheight()  #the purpose of -50 is to allow for space where the taskbar is on the bottom of the computer

screenWidthString = str(screenWidth)
screenHeightString = str(screenHeight)

guiSize = screenWidthString + "x" + screenHeightString

root.geometry(guiSize) #allows x,y size of GUI window to be set in terms of pixel number
root.resizable(True, True)
root.configure(background = 'gray89') #experiment with what color looks the best, this one doesnt matter (is hidden behind the notebook tabs)
root.title("Decisionics Lab Gait Analysis Tool")

img = ImageTk.PhotoImage(Image.open("images/UofT.jpg"))

root.wm_iconphoto(True, img)

icon = ImageTk.PhotoImage(Image.open("images/UofT.jpg"))
root.iconphoto(False, icon)
#######################################################################################################################################



########################################################################################################################################
#SECTION FOR DROP DOWN OPTIONS MENU AT TOP
rootMenu = Menu(root)
root.config(menu = rootMenu)


#FUNCTION DEFINITION
def aboutFunction():
    
    global aboutImage #if calling image within a function, global variable is needed to keep the image on the screen
    
    aboutWindow = Toplevel(root)
    aboutWindow.title("ABOUT")
    aboutWindow.geometry("500x500")
    aboutWindow.configure(background = 'gray89')
    aboutImage = ImageTk.PhotoImage(Image.open("images/decisionics.png"))
    aboutImageLabel = Label(aboutWindow, image = aboutImage)
    aboutImageLabel.place(relx = 0.5, rely = 0.4, anchor = "center")
    aboutLabel = Label(aboutWindow, text = "At Decisionics, we develop novel sensing devices and materials, \n adadpt and integrate commerically available sensors to create smart systems, \n and develop decision making frameworks to translate data collected from sensors \n into efficient remedial and functional strategies for engineering structures." \
        , font = ('Helvetica', 9), bg = 'gray89', fg = 'midnight blue')
    aboutLabel.place(relx = 0.5, rely = 0.7, anchor = "center")
    aboutButton = Button(aboutWindow, text = "EXIT", command = aboutWindow.destroy, bg = 'midnight blue', font = ('Helvetica', 13, 'bold'), fg = 'ghost white')
    aboutButton.place(relx = 0.5, rely = 0.83, anchor = "center")
    
    
def contactFunction():
    contactWindow = Toplevel(root)
    contactWindow.title("CONTACT")
    contactWindow.geometry("500x500")
    contactWindow.configure(background = 'gray89')
    contactLabel = Label(contactWindow, text = "Email contact information for the Decisionics Lab researchers is listed below:", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    contactLabel.place(relx = 0.5, rely = 0.25, anchor = "center")
    ericLabel = Label(contactWindow, text = "Eric Rendall - Graduate Student", font = 'Helvetica', bg = 'gray89', fg = 'midnight blue')
    ericLabel.place(relx = 0.5, rely = 0.35, anchor = "center")
    ericEmail = Label(contactWindow, text = "eric.rendall@mail.utoronto.ca", font = ('Helvetica', 8), bg = 'gray89', fg = 'midnight blue')
    ericEmail.place(relx = 0.5, rely = 0.40, anchor = "center")
    faeLabel = Label(contactWindow, text = "Dr. Faezeh Azhari - Principal Investigator & Lab Supervisor", font = 'Helvetica', bg = 'gray89', fg = 'midnight blue')
    faeLabel.place(relx = 0.5, rely = 0.52, anchor = "center")
    faeEmail = Label(contactWindow, text = "fae.azhari@utoronto.ca", font = ('Helvetica', 8), bg = 'gray89', fg = 'midnight blue')
    faeEmail.place(relx = 0.5, rely = 0.57, anchor = "center")
    contactButton = Button(contactWindow, text = "EXIT", command = contactWindow.destroy, bg = 'midnight blue', font = ('Helvetica', 13, 'bold'), fg = 'ghost white')
    contactButton.place(relx = 0.5, rely = 0.7, anchor = "center")
    

optionsMenu = Menu(rootMenu, tearoff = 0)
rootMenu.add_cascade(label = "OPTIONS", menu = optionsMenu)
optionsMenu.configure(background = 'gray89')

optionsMenu.add_command(label = "ABOUT", command = aboutFunction)
optionsMenu.add_separator()
optionsMenu.add_command(label = "CONTACT", command = contactFunction)
optionsMenu.add_separator()
optionsMenu.add_command(label = "EXIT PROGRAM", command = root.quit)
########################################################################################################################################



#########################################################################################################################################
#SECTION FOR CREATING THE GUI TABS
masterNotebook = ttk.Notebook(root)
masterNotebook.grid(row = 0, column = 0)

style = ttk.Style()
style.theme_use('default')
style.configure('TNotebook.Tab', background="gray70", font=('Helvetica','14'))
style.map("TNotebook", background= [("selected", "gray70")])


#now start to create frames - these will be the tabs within the notebook (the different pages of the app)
page1 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page1.pack(fill = "both", expand = 1)
masterNotebook.add(page1, text= "WELCOME!")

page2 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page2.pack(fill = "both", expand = 1)
masterNotebook.add(page2, text = "PROFILE")

page3 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page3.pack(fill = "both", expand = 1)
masterNotebook.add(page3, text = "SETUP")

page4 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page4.pack(fill = "both", expand = 1)
masterNotebook.add(page4, text = "DATA COLLECTION") 
#put CSV generation button in here

page5 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page5.pack(fill = "both", expand = 1)
masterNotebook.add(page5, text = "RAW FORCE DATA")

page6 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page6.pack(fill = "both", expand = 1)
masterNotebook.add(page6, text = "FILTERED ACCELERATION DATA")

page7 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page7.pack(fill = "both", expand = 1)
masterNotebook.add(page7, text = "GAIT PARAMETERS")

page8 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page8.pack(fill = "both", expand = 1)
masterNotebook.add(page8, text = "GAIT CYCLE PLOTS")

page9 = Frame(masterNotebook, width = screenWidth, height = screenHeight, bg = 'gray89')
page9.pack(fill = "both", expand = 1)
masterNotebook.add(page9, text = "THANK YOU!")
###################################################################################################################################



###################################################################################################################################################
#SECTION FOR ADDING TO PAGE1

global date_time

page1Image1 = ImageTk.PhotoImage(Image.open("images/engineering.png"))
page1ImageLabel1 = Label(page1, image = page1Image1)
page1ImageLabel1.place(relx = 0.3, rely = 0.2, anchor = "center")

page1Image = Image.open("images/decisionics.png")
resized_page1 = page1Image.resize((400,115), Image.ANTIALIAS)
newP1_IMAGE = ImageTk.PhotoImage(resized_page1)
p1IMAGE_Label = Label(page1, image = newP1_IMAGE)
p1IMAGE_Label.place(relx = 0.7, rely = 0.2, anchor = "center")

welcomeLabel = Label(page1, text = "Welcome to the Gait Analysis Tool.", font = ('Helvetica', 24), bg = 'gray89', fg = 'midnight blue')
welcomeLabel.place(relx = 0.5, rely = 0.34, anchor = "center")

login_label = Label(page1, text = "Login:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
login_label.place(relx = 0.47, rely = 0.4, anchor = "center")

login_Entry = Entry(page1, bg = 'ghost white', font = ('Helvetica', 12)) 
login_Entry.place(relx = 0.52, rely = 0.4, anchor = "center", height = 30, width = 100)

#HERE GOING TO CREATE A DATE TIME VARIABLE THAT WILL BE TAGGED TO THE DATA SETS 
date_time = datetime.now().strftime("%y%m%d-%H%M") #gonna leave this here but going to redefine this later on w start test button cause when
#adding new patient, this doesnt run again and the file gets overwritten if same patient having a second test

#NOW FOR THE PURPOSE OF THE PDF SINCE CANT HAVE / IN FILE NAMES
now = datetime.now()
dt_string = now.strftime("%d/%m/%Y %H:%M") #this will come from the generated datetime string in the app
#ALSO NEED TO REDO THIS IN START TEST FUNCTION AND OVERWRITE HERE CAUSE THIS IS WHAT GETS TAGGED ON TO PDF

#define login function
def login_function():

    global verify_user #so can be accesed when trying to save data later on in page4

    verify_user = login_Entry.get() #pulls the data from the entry field     

    if len(verify_user) != 6: #this must be the length of the username as defined

        errorMessage_p1 = Label(page1, text = "ERROR!", font = ('Helvetica', 13), fg = 'red4', bg = 'gray89')
        errorMessage_p1.place(relx = 0.5, rely = 0.52, anchor = "center")
        root.update()

        errorMessage2_p1 = Label(page1, text = "Please Enter Valid Username", font = ('Helvetica', 13), fg = 'red4', bg = 'gray89')
        errorMessage2_p1.place(relx = 0.5, rely = 0.55, anchor = "center")
        root.update()

        time.sleep(3)
        errorMessage_p1.destroy()
        errorMessage2_p1.destroy()
        login_Entry.delete(0, END)
        root.update()

    else:

        login_table = pd.read_csv('users.csv') #loads in the USER data csv
        user_exists = verify_user in login_table['USERS'].values

        if user_exists == True:

            masterNotebook.select(page3) #if returning user, can skip to setup section
            #here we do not clear the entry field
            login_Entry['state'] = DISABLED
            emailEntry['state'] = DISABLED #this is so that a new user cant be entered messing with how the full data ends up being saved

        else:

            errorMessage_p1 = Label(page1, text = "ERROR!", font = ('Helvetica', 13), fg = 'red4', bg = 'gray89')
            errorMessage_p1.place(relx = 0.5, rely = 0.52, anchor = "center")
            root.update()

            errorMessage2_p1 = Label(page1, text = "User Does Not Exist", font = ('Helvetica', 13), fg = 'red4', bg = 'gray89')
            errorMessage2_p1.place(relx = 0.5, rely = 0.55, anchor = "center")
            root.update()

            time.sleep(3)
            errorMessage_p1.destroy()
            errorMessage2_p1.destroy()
            login_Entry.delete(0, END)
            root.update()


login_button = Button(page1, text = "VERIFY USERNAME", font = ('Helvetica', 13, 'bold'), fg = 'midnight blue', bg = 'gray70', command = login_function)
login_button.place(relx = 0.5, rely = 0.46, anchor = "center", height = 50, width = 190)

def welcomeButtonFunction():
    masterNotebook.select(page2)

    login_Entry.delete(0, END)
    login_Entry['state'] = DISABLED

welcomeButton = Button(page1, text = "CREATE NEW PROFILE", command = welcomeButtonFunction, bg = 'midnight blue', font = ('Helvetica', 13, 'bold'), fg = 'ghost white')
welcomeButton.place(relx = 0.5, rely = 0.65, anchor = "center", height = 50, width = 210)
###################################################################################################################################################



#################################################################################################################################################
#SECTION FOR ADDING TO PAGE2

#ADD IN PAGE 2 STICK MAN PHOTO THING
page2Image = Image.open("images/gaitFigure.png")
resized_page2 = page2Image.resize((205,220), Image.ANTIALIAS)
newP2_IMAGE = ImageTk.PhotoImage(resized_page2)
p2IMAGE_Label = Label(page2, image = newP2_IMAGE)
p2IMAGE_Label.place(relx = 0.65, rely = 0.43, anchor = "center")

#UNIQUE ID FOR PATIENT WILL BE GENERATED UNDER THE HOOD AND ATTACHED TO CSV
createUserLabel = Label(page2, text = "CLIENT PROFILE", font = ('Helvetica', 24), bg = 'gray89', fg = 'midnight blue')
createUserLabel.place(relx = 0.5, rely = 0.08, anchor = "center")

usernameExample = Label(page2, text = "[initials + 4 digits] (e.g., ER1234)", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
usernameExample.place(relx = 0.64, rely = 0.14, anchor = "center")

#Occupation selection drop down...
OccupationLabel = Label(page2, text = "Occupation:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
OccupationLabel.place(relx = 0.291, rely = 0.51, anchor = "center")
occupationVariable = StringVar(page2) #no .set because dont want a preset value
#occupationVariable.set("")
occupationList = OptionMenu(page2, occupationVariable, "Employed", "Unemployed", "Disability Leave")
occupationList.config(bg = 'ghost white')
occupationList.place(relx = 0.35, rely = 0.51, anchor = "center", height = 50, width = 60)

#email section
emailEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12)) #make box longer to fit entire email
emailEntry.place(relx = 0.5, rely = 0.14, anchor = "center", height = 30, width = 230)
emailEntryLabel = Label(page2, text = "Username:", bg = 'gray89', font = ('Helvetica', 16), fg = 'midnight blue')
emailEntryLabel.place(relx = 0.41, rely = 0.14, anchor = "center")

#create drop down lists
#gender list
genderLabel = Label(page2, text = "Gender:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
genderLabel.place(relx = 0.3, rely = 0.26, anchor = "center")
#genderEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12))
#genderEntry.place(relx = 0.35, rely = 0.26, anchor = "center", height = 30, width = 100)
genderVariable = StringVar(page2)
genderList = OptionMenu(page2, genderVariable, "Male", "Female", "Other")
genderVariable.set("Male")
genderList.config(bg = 'ghost white')
genderList.place(relx = 0.35, rely = 0.26, anchor = "center", height = 50, width = 60)

#section for activity level + amputation year(s)
ampYearLabel = Label(page2, text = "Amputation Year(s):", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
ampYearLabel.place(relx = 0.65, rely = 0.26, anchor = "center")

ampYearEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12))
ampYearEntry.place(relx = 0.7475, rely = 0.26, anchor = "center", height = 30, width = 150)

#amputation type list, to be able to select multiple, create a ListBox object
amputationLabel = Label(page2, text = "Amputation Type(s):", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
amputationLabel.place(relx = 0.65, rely = 0.31, anchor = "center")

amputationOptions = ["Right Below Knee",
                     "Left Below Knee",
                     "Right Above Knee",
                     "Left Above Knee",
                     "Right Knee Disarticulation",
                     "Left Knee Disarticulation",
                     "Right Hip Disarticulation",
                     "Left Hip Disarticulation",
                     "Right Ankle Disarticulation",
                     "Left Ankle Disarticulation"] #Add more to this list if needed

amputationOptionsSelect = Listbox(page2, selectmode = "multiple")
amputationOptionsSelect.config(bg = 'ghost white', font = ('Helvetica', 11), fg = 'midnight blue')
amputationOptionsSelect.place(relx = 0.76, rely = 0.39, anchor = "center", width = 200)

for amputationItem in amputationOptions:
    amputationOptionsSelect.insert(END, amputationItem)
    
#prosthesis description
prosthesisLabel = Label(page2, text = "Prosthesis Description:", bg = 'gray89', fg = 'midnight blue', font = ('Helvetica', 16))
prosthesisLabel.place(relx = 0.64, rely = 0.56, anchor = "center")

#prosthesisEntry = Entry(page2, bg = 'ghost white')
#instead here will try text box widget as it allows for wrapping text
#prosthesisEntry.place(relx = 0.7725, rely = 0.57, anchor = "center", height = 30, width = 250)
prosthesisEntry = Text(page2, height = 10, width = 27, bg = 'ghost white', fg = 'midnight blue', font = ('Helvetica', 12))
prosthesisEntry.place(relx = 0.7725, rely = 0.555, anchor = "n")

#height entry
heightLabel = Label(page2, text = "Height [cm]:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
heightLabel.place(relx = 0.29, rely = 0.31, anchor = "center")
heightEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12))
heightEntry.place(relx = 0.35, rely = 0.31, anchor = "center", height = 30, width = 100)

#weight entry
weightLabel = Label(page2, text = "Weight [kg]:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
weightLabel.place(relx = 0.29, rely = 0.36, anchor = "center")
weightEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12))
weightEntry.place(relx = 0.35, rely = 0.36, anchor = "center", height = 30, width = 100)

#age entry
ageLabel = Label(page2, text = "Age [years]:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
ageLabel.place(relx = 0.29, rely = 0.41, anchor = "center")
ageEntry = Entry(page2, bg = 'ghost white', font = ('Helvetica', 12))
ageEntry.place(relx = 0.35, rely = 0.41, anchor = "center", height = 30, width = 100)

#activity level selection
activityLevel_Label = Label(page2, text = "Activity Level:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
activityLevel_Label.place(relx = 0.285, rely = 0.46, anchor = "center")

activityType = StringVar(page2)
activity_List = OptionMenu(page2, activityType, "LOW", "MEDIUM", "HIGH")
activity_List.config(bg = 'ghost white')
activity_List.place(relx = 0.35, rely = 0.46, height = 50, width = 60, anchor = "center")

#comorbidity 
comorbidityLabel = Label(page2, text = "Comorbidity?", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
comorbidityLabel.place(relx = 0.29, rely = 0.56, anchor = "center")
comorbidityVariable = StringVar(page2) #no .set because dont want a preset value
comorbidityVariable.set("NO")
comorbidityList = OptionMenu(page2, comorbidityVariable, "YES", "NO")
comorbidityList.config(bg = 'ghost white')
comorbidityList.place(relx = 0.35, rely = 0.56, anchor = "center", height = 50, width = 60)
         
specifyCOMORLabel = Label(page2, text = "Specifiy:", font = ('Helvetica', 16), bg = 'gray89', fg = 'midnight blue')
specifyCOMORLabel.place(relx = 0.295, rely = 0.6075, anchor = "center")

#comorbidityEntry = Entry(page2, bg = 'ghost white')
#comorbidityEntry.place(relx = 0.35, rely = 0.57, anchor = "center", height = 30, width = 150)
#we will again here try a text entry widget for wrapping purposes
comorbidityEntry = Text(page2, height = 7, width = 21, bg = 'ghost white', fg = 'midnight blue', font = ('Helvetica', 12))
comorbidityEntry.place(relx = 0.3725, rely = 0.605, anchor = "n")


#DATA CONFIRMATION BUTTON
def confirmationButtonFunction():
    
    
    global weightLogic
    global ageLogic
    
    
    #try catch error handling here for weight so that a bunch of random CSV's aren't generated
    
    weightTest = weightEntry.get()
    ageTest = ageEntry.get()
    
    try:
        error = float(weightTest) #tests for integer entry
        error1 = float(ageTest)
        
        1/error #if passes integer check, filter out 0 entry also, MAKES SURE WEIGHT CANNOT = 0!!!!!!
        1/error1
        
        weightLogic = True
        ageLogic = True
        
        p2SubmitButton['state'] = NORMAL #CLICKING THIS BUTTON WILL ALLOW THE SUBMIT USER DATA BUTTON TO BE CLICKED
        confirmationButton['state'] = DISABLED

        #disable weight entry section 
        weightEntry['state'] = DISABLED
        ageEntry['state'] = DISABLED
        
    except: #if the user forgets to enter in weight or if mistypes and enters string
        weightLogic = False
        ageLogic = False
        
        errorLabel = Label(page2, text = "ERROR!", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
        errorLabel.place(relx = 0.5, rely = 0.23, anchor = "center")
        root.update()

        enterValidValueLabel = Label(page2, text = "Please Enter a Valid Weight & Age", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
        enterValidValueLabel.place(relx = 0.5, rely = 0.25, anchor = "center")
        root.update()
        
        time.sleep(5)
        enterValidValueLabel.destroy() #this makes sure this label is gone even when adding a new patient 
        errorLabel.destroy()
        root.update()

    #also need to check for banned characters in username entry that will stop the file from being saved 
    #username_Test = emailEntry.get()

    #not sure how to make that work for now



confirmationButton = Button(page2, text = "CONFIRM", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = confirmationButtonFunction)
confirmationButton.place(relx = 0.5, rely = 0.74, anchor = "center", height = 40, width = 100)
confirmationButton['state'] = DISABLED


#SUBMIT PATIENT INFO BUTTON6
def p2SubmitButtonFunction(): #this function needs to grab all user input data as well as pull email to use as patient identifier 
    #EVERYTHING IN HERE MUST BE DEFINED AS GLOBAL SO THAT IT CAN BE USED LATER IN THE BACKEND 
    
    global patientEmail
    global patientGender
    global patientHeight
    global patientWeight
    global patientAge
    global patientComorbidity
    global patientComorbidityType
    global patientAmputation
    global PATIENTDATALIST
    global submitdataLabel
    global gonextpageLabel
    global csvIntakeDataButton

    global patientOccupation
    global patientActivityLevel
    global patientAmputationYear
    
    global weightLogic #to be used for label deletion in page 9 during add new patient 
    global enterValidValueLabel #the one to be deleted if weightLogic is false
    
    patientEmail = emailEntry.get() #THIS IS A SUPER IMPORTANT VARIABLE GOING FORWARD 
    
    patientGender = genderVariable.get()
    
    patientHeight = heightEntry.get()
    
    patientWeight = weightEntry.get()
    #HERE WE NEED ERROR EXCEPTION AS WEIGHT WILL BE USED TO NORMALIZE FSR DATA AND WE REQUIRE AN INTEGER HERE
    
    patientAge = int(ageEntry.get()) #THIS NEEDS TO BE CAST FROM STRING TO INT HERE 
    
    patientComorbidityBOOLEAN = comorbidityVariable.get()
    patientComorbidityType = comorbidityEntry.get("1.0",'end-1c') #since text entry type rather than entry widget
    
    
    #now getting multiple selections of amputation type from listbox is a bit tricky 
    patientAmputation = [amputationOptionsSelect.get(index) for index in amputationOptionsSelect.curselection()] #SUPER USEFUL FOR FUTURE WHEN PULLING MULTIPLE SELECTIONS
    
    prosthesisDescription = prosthesisEntry.get("1.0",'end-1c') #since text entry type rather than entry widget

    patientOccupation = occupationVariable.get()

    patientActivityLevel = activityType.get()

    patientAmputationYear = ampYearEntry.get()
    
    
    PATIENTDATALIST = [f'username: {patientEmail}', 
                       f'gender: {patientGender}', 
                       f'height (cm): {patientHeight}', 
                       f'weight (kg): {patientWeight}', 
                       f'age: {patientAge}', 
                       f'comorbidity: {patientComorbidityBOOLEAN}',
                       f'comorbidity type: {patientComorbidityType}', 
                       f'amputation: {patientAmputation}',
                       f'prosthesis description: {prosthesisDescription}',
                       f'occupation: {patientOccupation}',
                       f'activity level: {patientActivityLevel}',
                       f'amputation year: {patientAmputationYear}']

        
    global randomAlphaNumericCode #global as needs to be used in save data csv button later
        
        
    stringLength = 4 #number of characters in the randomly generated string
        
    #generate random alpha numeric string to be tagged to csv in case of clinician forgetting to enter in email address twice 
    #avoids the potential overwriting of a CSV w name _BIODATA.csv
    randomLetters = string.ascii_uppercase
    randomNumbers = string.digits
        
    randomLetterCode = ''.join(random.choice(randomLetters) for i in range(stringLength))
    randomNumberCode = ''.join(random.choice(randomNumbers) for i in range(stringLength))
        
    randomList = list(randomLetterCode + randomNumberCode)
    random.shuffle(randomList)
    # convert list to string
        
    randomAlphaNumericCode = ''.join(randomList) #THIS IS THE IMPORTANT VARIABLE   
    
    ###HERE CREATE ALL REQUIRED DIRECTORIES FOR PATIENT ONCE USERNAME HAS BEEN CONFIRMED
    global dir0
    global dir1
    global dir2
    global dir3
    global dir4
    
    USERNAME = patientEmail #this has already been confirmed as availble username
    dir0 = f'{patientEmail}_UserData' #all other folders will be nested within this folder
    dir1 = f'{dir0}/{patientEmail}_BioData'
    dir2 = f'{dir0}/{patientEmail}_RawData'
    dir3 = f'{dir0}/{patientEmail}_IMU_FSR_Parameters'
    dir4 = f'{dir0}/{patientEmail}_TestReports'
    
    if not os.path.exists(dir0): #this somehow creates dir1,2,3,4 within dir0. NVM IT DOESNT FUCK
        os.mkdir(dir0)
        os.mkdir(dir1)
        os.mkdir(dir2)
        os.mkdir(dir3)
        os.mkdir(dir4)
        
    with open(f'{dir1}/{patientEmail}_BIODATA.csv', 'w', newline = '') as page2CSV: #since this only needs to exist once per user, don't need datetime or random string tagged on. Need to access this file if user returning and logging in to pull weight, age, and gender for normalization and normative data base data pulling
        page2writer = csv.writer(page2CSV)
        page2writer.writerow(PATIENTDATALIST)
        
     
    if weightLogic == True and ageLogic == True:
        masterNotebook.select(page3)
        p2SubmitButton['state'] = DISABLED
        
        #NOW IN HERE WRITE TO THE USERS CSV
        temp_df = pd.DataFrame(columns = ['USERS'], index = [0])

        temp_df['USERS'] = username_check
        
        users_table = pd.read_csv('users.csv')

        users_table = users_table.append(temp_df)

        pd.DataFrame.to_csv(users_table, 'users.csv', index = False)

    else:
        pass
    

p2SubmitButton = Button(page2, text = "SUBMIT", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = p2SubmitButtonFunction)
p2SubmitButton.place(relx = 0.5, rely = 0.8, anchor = "center", height = 40, width = 100)
p2SubmitButton['state'] = DISABLED

#CREATE BUTTON TO CHECK USERS CSV FOR EXISTING USERNAME 
def check_username_function():

    global username_check
    global users_table

    users_table = pd.read_csv('users.csv') #this relies on a users CSV existing in the same folder as the executable
    username_check = emailEntry.get() #lazy so just leaving it as email entry even though its actually the username entry field now

    #now want to filter out empty string in case they forget to enter in username before clicking check button
    if username_check == "" or len(username_check) != 6: #if using TWO initials and FOUR numbers the length of the entry must be 6

        errorLabel = Label(page2, text = "ERROR!", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
        errorLabel.place(relx = 0.5, rely = 0.23, anchor = "center")
        root.update()

        enterValidValueLabel = Label(page2, text = "Please Enter a Valid Username", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
        enterValidValueLabel.place(relx = 0.5, rely = 0.25, anchor = "center")
        root.update()

        time.sleep(5)
        errorLabel.destroy()
        enterValidValueLabel.destroy()
        root.update()

    else: #else if ENTRY IS NOT EMPTY STRING NOW CHECK THE USERS COLUMN FOR A MATCH 

        a = username_check[0]
        b = username_check[1]
        c = username_check[2]
        d = username_check[3]
        e = username_check[4]
        f = username_check[5]


        #THIS BASICALLY MAKES SURE ITS OF FORMAT letter letter number number number number. Also eliminates any special characters that would get rejected by windows during file naming

        if a.isalpha() == True and b.isalpha() == True and c.isdigit() == True and d.isdigit() == True and e.isdigit() == True and f.isdigit() == True:

            name_exists = username_check in users_table['USERS'].values #USERS is the column name it will search so this must exist in the CSV file
            #the above should return a BOOLEAN EXPRESSION

            if name_exists == True:
                errorLabel = Label(page2, text = "ERROR!", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
                errorLabel.place(relx = 0.5, rely = 0.23, anchor = "center")
                root.update()

                enterValidValueLabel = Label(page2, text = "Username Already Exists", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
                enterValidValueLabel.place(relx = 0.5, rely = 0.25, anchor = "center")
                root.update()

                time.sleep(5)
                errorLabel.destroy()
                enterValidValueLabel.destroy()
                root.update()

            else:
                #now here write to the csv with the entered username

                #going to write to users CSV in same function that submits BIOMETRIC data so that they cant create the user then exit out and not have the BIO data associated
                #and then log back in with no bio data

                successLabel = Label(page2, text = "SUCCESS!", font = ('Helvetica', 14), bg = 'gray89', fg = 'green2')
                successLabel.place(relx = 0.5, rely = 0.23, anchor = "center")
                root.update()

                time.sleep(5)
                successLabel.destroy()
                root.update()

                confirmationButton['state'] = NORMAL
                check_username_button['state'] = DISABLED

                #also disable the entry for username now it has passed all the checks, just to make sure it cant be changed 
                emailEntry['state'] = DISABLED

            

        else:
            errorLabel = Label(page2, text = "ERROR!", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
            errorLabel.place(relx = 0.5, rely = 0.23, anchor = "center")
            root.update()

            enterValidValueLabel = Label(page2, text = "Please Enter a Valid Username", font = ('Helvetica', 14), bg = 'gray89', fg = 'red4')
            enterValidValueLabel.place(relx = 0.5, rely = 0.25, anchor = "center")
            root.update()

            time.sleep(5)
            errorLabel.destroy()
            enterValidValueLabel.destroy()
            root.update()

            

check_username_button = Button(page2, text = "Check Username Availability", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'red4', command = check_username_function)
check_username_button.place(relx = 0.5, rely = 0.19, anchor = "center", height = 40)

#add in page help button

def p2HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page2_HELP = Button(page2, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p2HELP_FUNCTION)
page2_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)
###################################################################################################################################################



#####################################################################################################################################################
#SECTION FOR ADDING TO PAGE3
#this page will probably have a few images detailing how to calibrate the IMU + CONNECTING AND ESTABLISHING LINK W BOTH ESP32's

#NUMBER CODE FOR COMMUNICATION AND SWITCH CASE STATES INTERFACING W THE HARDWARE
#**************************************************************************************
#define PAIRING 0
#define SELECT_SIDE 101
#define CALIBRATION 102
#define MEASUREMENT 103
#define FINISHED_MEASUREMENT 104
#define ACK_PAIR    105
#define FLASH_LEFT  106
#define FLASH_RIGHT 107
#define START_TEST 108 //this should come from the start test button on page 4
#define SIDE_ASSIGNED 109
#******************************************************************************************

#ADD IN PAGE 3 IMAGE
#page3Image = Image.open("Calibration.png")
#resized_page3 = page3Image.resize((325,400), Image.ANTIALIAS)
#newP3_IMAGE = ImageTk.PhotoImage(resized_page3)
#p3IMAGE_Label = Label(page3, image = newP3_IMAGE)
#p3IMAGE_Label.place(relx = 0.5, rely = 0.37, anchor = "center")

def instructionsFunction(): #pop out a frame that contains the GIF
    instructionsWindow = Toplevel(root)
    instructionsWindow.title("CALIBRATION INSTRUCTIONAL VIDEO")
    instructionsWindow.geometry("800x900")
    instructionsWindow.configure(background = 'gray89')
    
    instructions_label = Label(instructionsWindow, text = "PLEASE FOLLOW MOTIONS IN THE VIDEO BELOW TO CALIBRATE THE DEVICES:", font = 'Helvetica 14 underline', bg = 'gray89', fg = 'midnight blue')
    instructions_label.place(relx = 0.5, rely = 0.1, anchor = "center")
    
    #HERE ADD IN THE GIF SOMEHOW 
    
    global infoGIF
     
    infoGIF = Image.open("images/calibration_GIF.gif")
    
    gif_lbl = Label(instructionsWindow)
    gif_lbl.place(relx = 0.5, rely = 0.5, anchor = "center")
    
    for infoGIF in ImageSequence.Iterator(infoGIF):
        #infoGIF = infoGIF.resize((300,300))
        infoGIF = ImageTk.PhotoImage(infoGIF)
        
        gif_lbl.config(image = infoGIF)
        root.update()
        time.sleep(0.1)
        
    #root.after(0, instructionsFunction)
    
    aboutButton = Button(instructionsWindow, text = "EXIT", command = instructionsWindow.destroy, bg = 'midnight blue', font = ('Helvetica', 13, 'bold'), fg = 'ghost white')
    aboutButton.place(relx = 0.5, rely = 0.85, anchor = "center")

#BUTTON THAT POPS OUT WINDOW WITH GIF FOR CALIBRATION INSTRUCTIONS
calibration_instructions = Button(page3, text = "CALIBRATION INSTRUCTIONS", font = ('Helvetica', 13, 'bold'), fg = 'ghost white', bg = 'midnight blue', command = instructionsFunction)
calibration_instructions.place(relx = 0.5, rely = 0.35, anchor = "center")


page3IntroLabel = Label(page3, text = "SETUP & CALIBRATION", bg = 'gray89', font = ('Helvetica', 24), fg = 'midnight blue')
page3IntroLabel.place(relx = 0.5, rely = 0.08, anchor = "center")


#DEFINE NEEDED FUNCTIONS FOR FINDING SERIAL PORTS
def get_ports():
    ports = serial.tools.list_ports.comports()
    return ports


#LEFT LEG

LeftLegLabel = Label(page3, text = "LEFT FOOT", bg = 'gray89', font = ('Helvetica 24 underline'), fg = 'red4')
LeftLegLabel.place(relx = 0.2, rely = 0.2, anchor = "center")

#create label list 
left_1 = Label(page3, text = "1. Turn on both circuit boards.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_1.place(relx = 0.15, rely = 0.25, anchor = "w")

left_2 = Label(page3, text = "2. Scan for left foot device.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_2.place(relx = 0.15, rely = 0.29, anchor = "w")

left_3 = Label(page3, text = "3. Once the device light turns RED,", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_3.place(relx = 0.15, rely = 0.33, anchor = "w")

left_3_2 = Label(page3, text = "place to the side and click Confirm.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_3_2.place(relx = 0.161, rely = 0.352, anchor = "w")

left_4 = Label(page3, text = "4. If right foot has not yet been connected,", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_4.place(relx = 0.15, rely = 0.435, anchor = "w")

left_4_2 = Label(page3, text = "please follow the right foot steps.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_4_2.place(relx = 0.161, rely = 0.4572, anchor = "w")

left_5 = Label(page3, text = "5. Once both devices have been connected \n and confirmed, you may start calibration.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
left_5.place(relx = 0.15, rely = 0.51, anchor = "w")


#RIGHT LEG

RightLegLabel = Label(page3, text = "RIGHT FOOT", bg = 'gray89', font = ('Helvetica 24 underline'), fg = 'blue')
RightLegLabel.place(relx = 0.725, rely = 0.2, anchor = "center")

#create label list 
right_1 = Label(page3, text = "1. Turn on both circuit boards.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_1.place(relx = 0.67, rely = 0.25, anchor = "w")

right_2 = Label(page3, text = "2. Scan for right foot device.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_2.place(relx = 0.67, rely = 0.29, anchor = "w")

right_3 = Label(page3, text = "3. Once the device light turns BLUE,", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_3.place(relx = 0.67, rely = 0.33, anchor = "w")

right_3_2 = Label(page3, text = "place to the side and click Confirm.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_3_2.place(relx = 0.681, rely = 0.352, anchor = "w")

right_4 = Label(page3, text = "4. If left foot has not yet been connected,", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_4.place(relx = 0.67, rely = 0.435, anchor = "w")

right_4_2 = Label(page3, text = "please follow the left foot steps.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_4_2.place(relx = 0.681, rely = 0.4572, anchor = "w")

right_5 = Label(page3, text = "5. Once both devices have been connected \n and confirmed, you may start calibration.", bg = 'gray89', font = ('Helvetica', 14), fg = 'midnight blue')
right_5.place(relx = 0.67, rely = 0.51, anchor = "w")


def scanLeft():
    
    global leftCOMPort
    global serLEFT #needs to be accessed for calibration and starting test
    
    scanLeftLegButton['state'] = DISABLED
    
    leftFound = get_ports()
    leftCOMPort = 'None' #THIS IS THE IMPORTANT ONE AND WILL BE CHANGED LATER ON, may want to comment this out
    numberPorts = len(leftFound)
    #COM3 - Standard Serial over Bluetooth link (COM3) this is the format of the returned string
    
    for index in range(0, numberPorts): #DONT DO -1 FOR SOME REASON, range accounts for the index starting at ZERO
        leftPortTRY = leftFound[index]
        strleftPortTRY = str(leftPortTRY) #convert to useable string for string splitting to parse out com value
        
        if 'Bluetooth' in strleftPortTRY: #this comes from the windows formatting of bluetooth comports in the comment above
            leftSPLIT = strleftPortTRY.split(' ') #split case based on SPACE
            
            leftCOMPort = leftSPLIT[0] #TAKES THE ZERO'th index based on the format will give exactly COM3, etc...
            
            #here we write to COM port and also read from COM port to make sure we get the right one
            #now create serial object
            serLEFT = serial.Serial(leftCOMPort, 115200, timeout = 2) #same BAUD RATE as on PCB obviously
            #serLEFT = serial.Serial(leftCOMPort, 115200, timeout = 5) #LONGER TIMEOUT MAY BE BETTER FOR SAFETY FACTOR BUT PROGRESS BAR CAN MOVE FASTER WITH LOWER TIMEOUT
            
            checkWorkingPort = serLEFT.readline()
            
            if b'A' in checkWorkingPort:
            
                #now write the ACK_PAIR string to the serial port to see if gets a reply for left side
                serLEFT.write(b'105')
                time.sleep(0.5) #just adding another delay to be safe
                
                serLEFT.flushInput() #to get rid of the A spam
                time.sleep(1) #THIS IS CRUCIAL TO ALLOW IT TO PROCESS THE FLUSH 
                    
                #then write FLASH_LEFT COMMAND
                serLEFT.write(b'106')
            
                #NOW NEED TO READ FROM SERIAL PORT
                confirmSERLEFT = serLEFT.readline()
            
                if b'LEFT' in confirmSERLEFT: #b'left' because it is a bytes object not a string object
                    confirmLeftButton['state'] = NORMAL #this should only happen once connection has been established
                    break
            
        
     
scanLeftLegButton = Button(page3, text = "SCAN LEFT FOOT", bg = 'gray70', font = ('Helvetica', 13, 'bold'), fg = 'red4', command = scanLeft)
scanLeftLegButton.place(relx = 0.13, rely = 0.39, anchor = "w")


def confirmLeftButtonFunction():
    scanRightLegButton['state'] = NORMAL
    confirmLeftButton['state'] = DISABLED


confirmLeftButton = Button(page3, text = "CONFIRM LEFT FOOT", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'red4', command = confirmLeftButtonFunction)
confirmLeftButton.place(relx = 0.32, rely = 0.39, anchor = "center")
confirmLeftButton['state'] = DISABLED


def scanRight():
    
    global serRIGHT #needs to be accessed for calibration and starting test
    
    scanRightLegButton['state'] = DISABLED
    
    rightFound = get_ports()
    rightCOMPort = 'None' #THIS IS THE IMPORTANT ONE AND WILL BE CHANGED LATER ON, may want to comment this out
    numberPorts1 = len(rightFound)
    #COM3 - Standard Serial over Bluetooth link (COM3) this is the format of the returned string
    
    for index1 in range(0, numberPorts1): #DONT DO -1 FOR SOME REASON, range accounts for the index starting at ZERO
        rightPortTRY = rightFound[index1]
        strrightPortTRY = str(rightPortTRY) #convert to useable string for string splitting to parse out com value
        
        if 'Bluetooth' in strrightPortTRY and leftCOMPort not in strrightPortTRY: #makes sure it doesnt retry the already opened left serial port
            rightSPLIT = strrightPortTRY.split(' ') #split case based on SPACE
            
            rightCOMPort = rightSPLIT[0] #TAKES THE ZERO'th index based on the format will give exactly COM3, etc...
            
            #here we write to COM port and also read from COM port to make sure we get the right one
            #now create serial object
            serRIGHT = serial.Serial(rightCOMPort, 115200, timeout = 2) #same BAUD RATE as on PCB obviously
            #serRIGHT = serial.Serial(rightCOMPort, 115200, timeout = 5) #LONGER TIMEOUT MAY BE BETTER FOR SAFETY FACTOR BUT PROGRESS BAR CAN MOVE FASTER WITH LOWER TIMEOUT
            
            checkWorkingPort1 = serRIGHT.readline()
            
            if b'A' in checkWorkingPort1:
            
                #now write the ACK_PAIR string to the serial port to see if gets a reply for left side
                serRIGHT.write(b'105')
                time.sleep(0.5) #added cause weird timing error
                
                serRIGHT.flushInput() #to get rid of the A spam
                time.sleep(1) #THIS IS CRUCIAL TO ALLOW IT TO PROCESS THE FLUSH 
                    
                #then write FLASH_LEFT COMMAND
                serRIGHT.write(b'107') #turns on blue LED
            
                #NOW NEED TO READ FROM SERIAL PORT
                confirmSERRIGHT = serRIGHT.readline()
            
                if b'RIGHT' in confirmSERRIGHT: #b'right' because it is a bytes object not a string object
                    confirmRightButton['state'] = NORMAL #this should only happen once connection has been established
                    break
    


scanRightLegButton = Button(page3, text = "SCAN RIGHT FOOT", bg = 'gray70', font = ('Helvetica', 13, 'bold'), fg = 'blue', command = scanRight)
scanRightLegButton.place(relx = 0.65, rely = 0.39, anchor = "w")
scanRightLegButton['state'] = DISABLED


def confirmRightButtonFunction():
    
    stealth_button['state'] = NORMAL
    
    global CalibrationImage
    global instructionsLabel
    global LsideLabel
    global RsideLabel
    
    global calibrationButton
    
    confirmRightButton['state'] = DISABLED
    
    instructionsLabel = Label(page3, text = "To calibrate, hold devices in the 6 orientations shown in the instructions tab for 2-3 seconds each. \n Repeat until both calibration values reach 3.", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    instructionsLabel.place(relx = 0.5, rely = 0.6, anchor = "center")
    
    LsideLabel = Label(page3, text = "LEFT", font = 'Helvetica', bg = 'gray89', fg = 'red4')
    LsideLabel.place(relx = 0.48, rely = 0.7, anchor = "center")
        
    RsideLabel = Label(page3, text = "RIGHT", font = 'Helvetica', bg = 'gray89', fg = 'blue')
    RsideLabel.place(relx = 0.52, rely = 0.7, anchor = "center")
    
    
    def calibrateFunction(): 
        
        #active stealth button in here
        stealth_button['state'] = DISABLED

        global LCALValue
        global RCALValue
        global doneCalibrationLabel
        
        #global LCAL
        #global RCAL
        
        global counter
        
        calibrationDone = False
        calibrationButton['state'] = DISABLED
        root.update()
        
        
        #here we write calibration state to both PCB's and pull the data to be live printed on the screen
        #once RIGHT and LEFT has been read from serial port in functions above, serial port empty and can now start reading in calibration values
        #need to convert byte type into integer
        
        serLEFT.flushInput()
        serRIGHT.flushInput()
        
        time.sleep(1) #probably need this again
        
        serLEFT.write(b'109')
        serRIGHT.write(b'109') #PUTS IN CALIBRATION STATE
        
        #counter = 0
        
        while calibrationDone == False:
            
            LEFTcalibrationVALUE = serLEFT.readline()
            RIGHTcalibrationVALUE = serRIGHT.readline()
            
            time.sleep(1)
            
            LEFTcalibrationVALUEconverted = str(LEFTcalibrationVALUE, 'utf-8') #this strips out the byte and newline character stuff
            try:
                LCAL = int(LEFTcalibrationVALUEconverted)
                #LCAL = LEFTcalibrationVALUEconverted #maybe keep it as a string
            except:
                LCAL = ''
            
            RIGHTcalibrationVALUEconverted = str(RIGHTcalibrationVALUE, 'utf-8')
            try:
                RCAL = int(RIGHTcalibrationVALUEconverted)
                #RCAL = RIGHTcalibrationVALUEconverted
            except:
                RCAL = ''
            
            #IMPORTANT, WHILE UTF-8 makes the data appear as int type, it is actually a string
            
            #print(LCAL) #for now just to see in terminal whats going on with the values
            #print(RCAL)
            
            #counter = counter + 1
            
            if LCAL == 0:
                LCALValue = Label(page3, text = "0", bg = 'gray89', font = ('Helvetica', 20), fg = 'red4')
                LCALValue.place(relx = 0.48, rely = 0.73, anchor = "center")
                root.update()
            elif LCAL == 1:
                LCALValue = Label(page3, text = "1", bg = 'gray89', font = ('Helvetica', 20), fg = 'red4')
                LCALValue.place(relx = 0.48, rely = 0.73, anchor = "center")
                root.update()
            elif LCAL == 2:
                LCALValue = Label(page3, text = "2", bg = 'gray89', font = ('Helvetica', 20), fg = 'red4')
                LCALValue.place(relx = 0.48, rely = 0.73, anchor = "center")
                root.update()
            elif LCAL == 3:
                LCALValue = Label(page3, text = "3", bg = 'gray89', font = ('Helvetica', 20), fg = 'red4')
                LCALValue.place(relx = 0.48, rely = 0.73, anchor = "center")
                root.update()
            else:
                pass
                
                
            if RCAL == 0:
                RCALValue = Label(page3, text = "0", bg = 'gray89', font = ('Helvetica', 20), fg = 'blue')
                RCALValue.place(relx = 0.52, rely = 0.73, anchor = "center")
                root.update()
            elif RCAL == 1:
                RCALValue = Label(page3, text = "1", bg = 'gray89', font = ('Helvetica', 20), fg = 'blue')
                RCALValue.place(relx = 0.52, rely = 0.73, anchor = "center")
                root.update()
            elif RCAL == 2:
                RCALValue = Label(page3, text = "2", bg = 'gray89', font = ('Helvetica', 20), fg = 'blue')
                RCALValue.place(relx = 0.52, rely = 0.73, anchor = "center")
                root.update()
            elif RCAL == 3:
                RCALValue = Label(page3, text = "3", bg = 'gray89', font = ('Helvetica', 20), fg = 'blue')
                RCALValue.place(relx = 0.52, rely = 0.73, anchor = "center")
                root.update()
            else:
                pass
                
            #destroy the Labels after each iteration
            #LCALValue.destroy()
            #RCALValue.destroy()
            
            if LCAL == 3 and RCAL == 3:
                
                calibrationDone = True
                
                page3NextButton['state'] = NORMAL
                
                doneCalibrationLabel = Label(page3, text = "CALIBRATION COMPLETE", bg = 'gray89', font = ('Helvetica', 24), fg = 'midnight blue')
                doneCalibrationLabel.place(relx = 0.5, rely = 0.69, anchor = "center")
            
            time.sleep(1) #matches with the ESP calibration measurement delay, needs to be higher than the esp delay because it seems to get ahead of the serial writing and times out
        
    
    calibrationButton = Button(page3, text = "CALIBRATE DEVICES", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = calibrateFunction)
    calibrationButton.place(relx = 0.5, rely = 0.645, anchor = "center")


confirmRightButton = Button(page3, text = "CONFIRM RIGHT FOOT", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'blue', command = confirmRightButtonFunction)
confirmRightButton.place(relx = 0.845, rely = 0.39, anchor = "center")
confirmRightButton['state'] = DISABLED

def retryLeft():
    scanLeftLegButton['state'] = NORMAL
    
def retryRight():
    scanRightLegButton['state'] = NORMAL

retryConnectionLeft = Button(page3, text = "RETRY", bg = 'gray70', font = ('Helvetica', 13, 'bold'), fg = 'midnight blue', command = retryLeft)
retryConnectionLeft.place(relx = 0.24, rely = 0.39, anchor = "center")

retryConnectionRight = Button(page3, text = "RETRY", bg = 'gray70', font = ('Helvetica', 13, 'bold'), fg = 'midnight blue', command = retryRight)
retryConnectionRight.place(relx = 0.765, rely = 0.39, anchor = "center")


#next button
def page3Next_FUNCTION():
    masterNotebook.select(page4)
    
    scanLeftLegButton['state'] = NORMAL
    instructionsLabel.destroy()
    LsideLabel.destroy()
    RsideLabel.destroy()
    
    #since the calibration values are compounding, need to destroy them all sequentially 
    #for z in range(1, counter + 1):
        #LCALValue.destroy()
        #RCALValue.destroy()
    
    doneCalibrationLabel.destroy()
    
    calibrationButton.destroy()
    
    page3NextButton['state'] = DISABLED
    

page3NextButton = Button(page3, text = "START TEST", bg = 'midnight blue', fg = 'ghost white', font = ('Helvetica', 13, 'bold'), command = page3Next_FUNCTION)
page3NextButton.place(relx = 0.5, rely = 0.78, anchor = "center", height = 50, width = 150)
page3NextButton['state'] = DISABLED


#section for page3 help button
def p3HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page3_HELP = Button(page3, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p3HELP_FUNCTION)
page3_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)

#CREATE SKIP BUTTON

global skipButton

skipLabel = Label(page3, text = "If you have previously calibrated the devices and left them powered on, \n click skip to move to the DATA COLLECTION page.", font = ('Helevetica', 12), bg = 'gray89', fg = 'midnight blue')
skipLabel.place(relx = 0.2, rely = 0.05, anchor = "center")

def skipFunction():
    skipButton['state'] = DISABLED
    masterNotebook.select(page4)
    

skipButton = Button(page3, text = "SKIP", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = skipFunction)
skipButton.place(relx = 0.2, rely = 0.1, anchor = "center", height = 50, width = 70)
skipButton['state'] = DISABLED

##ADD IN STEALTH BUTTON TO SKIP STUPID CALIBRATION
def stealthFunction():
    #stealth_button['state'] = DISABLED
    #open pop up window
    stealth_window = Toplevel(root)
    stealth_window.geometry("350x150")
    question_label = Label(stealth_window, text= "0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 ... ?", font=('Helvetica', 11, 'bold'))
    question_label.place(x = 175, y = 35, anchor = "center")
    root.update()
    answer_entry = Entry(stealth_window, bg = 'ghost white', font = ('Helvetica', 12))
    answer_entry.place(relx = 0.5, rely = 0.4, anchor = "center", height = 30, width = 200)
    
    def checkAnswer():
        response = answer_entry.get()
        if response == "233":
            calibrationButton['state'] = DISABLED
            stealth_button['state'] = DISABLED
            #now write the shyte PCB's into calibration mode cause based on the firmware the need to be in calibration mode to begin with to ever get into data collection mode
            serLEFT.flushInput()
            serRIGHT.flushInput()
        
            time.sleep(1) #probably need this again
        
            serLEFT.write(b'109')
            serRIGHT.write(b'109') #PUTS IN CALIBRATION STATE
            
            #now inluck start test button
            page3NextButton['state'] = NORMAL
            
            stealth_window.destroy()
        else:
            wrong_answer_label = Label(stealth_window, text = "nope", font = ('Helvetica', 12))
            wrong_answer_label.place(relx = 0.5, rely = 0.65, anchor = "center")
            root.update()
            time.sleep(2)
            wrong_answer_label.destroy()
            root.update()
    
    submit_answer_button = Button(stealth_window, text = "submit", font = ('Helvetica', 12), command = checkAnswer)
    submit_answer_button.place(relx = 0.5, rely = 0.8, anchor = "center")
    

stealth_button = Button(page3, command = stealthFunction)
stealth_button.place(relx = 0.95, rely = 0.5, anchor = "center")
stealth_button['state'] = DISABLED
###################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 4
#create keep or delete function w data that unlocks CSV generate button which in turn unlocks next button

global GRAVITY
GRAVITY = 9.81 #to be used in le math

beginTestLabel = Label(page4, text = "WALK TEST & DATA COLLECTION", font = ('Helvetica', 24), bg = 'gray89', fg = 'midnight blue')
beginTestLabel.place(relx = 0.5, rely = 0.08, anchor = "center")

#PLACE PAGE HELP BUTTON ON SCREEN

def p4HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page4_HELP = Button(page4, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p4HELP_FUNCTION)
page4_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)

#PAGE INSTRUCTIONS
p4_1 = Label(page4, text = "1. Establish a walking corridor (~ 50m). Have the client stand still at the starting point.", font = ('Helvetica', 14), bg = 'gray89', fg = 'midnight blue')
p4_1.place(relx = 0.2, rely = 0.18, anchor = "w")

p4_2 = Label(page4, text = "2. Once client is ready to walk, click the START button. Have the client stand still while the STAND sign is illuminated green.", font = ('Helvetica', 14), bg = 'gray89', fg = 'midnight blue')
p4_2.place(relx = 0.2, rely = 0.23, anchor = "w")

middleLabel = Label(page4, text = "Once the WALK sign turns green, ask the client to begin walking.", font = ('Helvetica', 14), bg = 'gray89', fg = 'midnight blue')
middleLabel.place(relx = 0.211, rely = 0.25, anchor = "w")

p4_3 = Label(page4, text = "3. If the test was successful, click the SUBMIT button (to save as CSV). If not, click RESET to start again.", font = ('Helvetica', 14), bg = 'gray89', fg = 'midnight blue')
p4_3.place(relx = 0.2, rely = 0.42, anchor = "w")


#CREATE PROGRESS BAR
style_bar = ttk.Style()
style_bar.configure("green.Horizontal.TProgressbar", foreground='green', background='green')
progressBAR = ttk.Progressbar(page4, style = "green.Horizontal.TProgressbar", orient = HORIZONTAL, length = 100, mode = 'determinate')
progressBAR.place(relx = 0.212, rely = 0.34, anchor = "w", height = 40, width = 450)

#LABEL INSIDE PROGRESS BAR?
progressLabel = Label(page4, text = "PROGRESS", font = ('Helvetica', 14, 'bold'), bg = 'gray78', fg = 'ghost white')
progressLabel.place(relx = 0.325, rely = 0.34, anchor = "center")

#time labels underneath progress bar
Zero_Label = Label(page4, text = "0 Sec", font = ('Helvetica', 13), fg = 'midnight blue', bg = 'gray89')
Zero_Label.place(relx = 0.22, rely = 0.37, anchor = "center")

Thirty_Label = Label(page4, text = "30 Sec", font = ('Helvetica', 13), fg = 'midnight blue', bg = 'gray89')
Thirty_Label.place(relx = 0.45, rely = 0.37, anchor = "center")

#attempt at multi-threading
#since know test is about 30 seconds in length, try running a parallel process for the progress bar by calling external function

progress = 0
i = None

def progressBarFunction():
    
    for i in range(0, 96):
        time.sleep(0.3)
        progress = i
        progressBAR['value'] = progress
        root.update()


#THIS FUNCTION IS WHERE THE DATA WILL BE COLLECTED
def startTestFunction(): #somewhere in here need an IF statement that will change the color of the button to green to indicate the test is done
    
    global date_time
    global dt_string
    
    #DEFINE TIME IN HERE FOR FILE SAVING
    date_time = datetime.now().strftime("%y%m%d-%H%M")
    
    now = datetime.now()
    dt_string = now.strftime("%d/%m/%Y %H:%M") #this will come from the generated datetime string in the app
    
    
    startTestButton['state'] = DISABLED #to prevent the button from being clicked twice
    
    #now we write to PCB to tell it to start data collection mode
    serLEFT.flushInput() #THIS SHOULD ALSO GET RID OF PRIOR DATA IN THE SERIAL PORT IF RESTARTING TEST
    serRIGHT.flushInput()
    time.sleep(1) #have to get rid of the calibration values clogging the serial ports
    
    serLEFT.write(b'108')
    serRIGHT.write(b'108')
    time.sleep(1)
    
    standButton.config(background = 'green')
    root.update()
    
    time.sleep(4) #4 second delay here since already 1 second delay after record data command sent via serial and want 5 total seconds of standing data before walking
    standButton.config(background = 'gray70')
    root.update()
    walkButton.config(background = 'green')
    root.update()
    
    #MULTITHREAD PROGRESS BAR TO GET IT TO RUN SMOOTH
    threading.Thread(target = progressBarFunction()).start()
    
    randomLogic = True
    leftDONE = False
    rightDONE = False

    #pBAR_multiplier = 0
    
    while randomLogic == True:
        waitLeft = serLEFT.readline() #have timeout function in serial objects so will just return empty string until Measurement_Done is printed
        waitRight = serRIGHT.readline()
        
        #pBAR_multiplier = pBAR_multiplier + 1
    
        #somehow update the progress bar in a way that makes some amount of sense...
        #progressBAR['value'] = pBAR_multiplier*8 #kinda arbitrary but basically solves the problem
        #root.update()
        #BROKE THE FOLLOWING STATEMENTS UP IN CASE OF TIMING ERRORS OR CORRUPT DATA FOR SOME REASON
        #should pass checks now
        
        if b"Measurement_Done" in waitLeft:
            leftDONE = True
            
            
        if b"Measurement_Done" in waitRight:
            rightDONE = True
            
        if leftDONE == True and rightDONE == True:
            
            randomLogic = False
            progressBAR['value'] = 100 #jump to 100% 
            root.update()
            
            #IMPORTANT:
            #must put into send data state in here because otherwise the test cannot be restarted unless in that state where it looks for command to start recording again
            
            serLEFT.flushInput()
            serRIGHT.flushInput()
            time.sleep(1)
            
            serLEFT.write(b'Confirm') 
            serRIGHT.write(b'Confirm')
    
    #THIS IS SUPER IMPORTANT TO HAVE THE DELAY HERE
    time.sleep(1) #this is here as a fail safe, can be modified depending on how fast the ESP can print 3000 lines to the serial ports w no delays
    #allows the program time to let all data come in thru serial port before moving to finished measurement state where discard and restart test becomes an option
    
    walkButton.config(background = 'gray70')
    root.update()
    
    DONElabel = Label(page4, text = "TEST COMPLETED!", font = ('Helvetica', 20), bg = 'gray89', fg = 'green')
    DONElabel.place(relx = 0.53, rely = 0.34, anchor = "center")
    root.update()
    
    time.sleep(3)
    DONElabel.destroy()
    root.update()
    
    keep_Button['state'] = NORMAL #make sure this happens at the end of the function and within an IF statement so that data can't be submitted until collecteion process done
    resetTEST_Button['state'] = NORMAL
    
global startTestButton #so that it can be reset on last page for another test    

startTestButton = Button(page4, text = "START", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = startTestFunction)
startTestButton.place(relx = 0.2325, rely = 0.29, anchor = "center", height = 40, width = 80)
startTestButton['state'] = NORMAL

standButton = Button(page4, text = "STAND", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white') #no command since basically using as a flag
standButton.place(relx = 0.29, rely = 0.29, anchor = "center", height = 40, width = 80)
standButton['state'] = DISABLED

walkButton = Button(page4, text = "WALK", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white')
walkButton.place(relx = 0.3475, rely = 0.29, anchor = "center", height = 40, width = 80)
walkButton['state'] = DISABLED


def keepFunction():
    
    global patientGender
    global patientWeight
    global patientAge
    
    global patientAmputation
    
    #SINCE PATIENT WEIGHT NEEDS TO EXIST FOR THIS FUNCTION TO RUN, HERE IS WHERE WE WILL PULL THE BIODATA FROM THE CSV FILE IF RETURNING USER WHO LOGGED IN
    first_time_user = emailEntry.get() #this is the username creation field on page 2
    user_logged_in = login_Entry.get() #this is the login field on page 1, if this is used, then page 2 will be skipped entirely 

    if len(first_time_user) > 0 and len(user_logged_in) == 0:
        
        pass #nothing has to happen because this means they are new user and patient weight, gender, and age will already exist

    elif len(user_logged_in) > 0 and len(first_time_user) == 0:

        #now in here must pull the necessary data from the patients BIODATA file and save the proper variables
        #seeing as the user must have successfully logged in, there must be a BIODATA file from which to pull data
        get_user_data_from_CSV = pd.read_csv(f'{user_logged_in}_UserData/{user_logged_in}_BioData/{user_logged_in}_BIODATA.csv')
        data_COLUMNS = get_user_data_from_CSV.columns
        
        extract_GENDER = data_COLUMNS[1] #this is the formatting of the CSV, the 1st index column contains the gender entry
        extract_WEIGHT = data_COLUMNS[3]
        extract_AGE = data_COLUMNS[4]
        
        #ALSO NEED TO HANDLE AMPUTATION TYPE BECAUSE THIS IS NEEDED FOR THE LEGEND IN THE GRAPHING ON PAGE 5
        extract_Amputation = data_COLUMNS[7]
        patientAmputation = extract_Amputation
        
        #NOW CAN HANDLE THE GENDER EASILY SINCE ONLY NEED A STRING THAT CONTAINS THE GENDER FOR CODE TO WORK, CAN ALSO HAVE OTHER LETTERS WHICH IT WILL FROM TITLE
        patientGender = extract_GENDER
        
        #NOW NEED TO PARSE THE NUMBERS OUT OF THE WEIGHT AND AGE VARIABLES TO BE ABLE TO CONVERT TO INTEGERS
        temp_Weight = []
        for weight_letter in extract_WEIGHT:
            weight_test = weight_letter.isdigit()
            if weight_test == True:
                temp_Weight.append(weight_letter) #now have a list that contains the individual numbers as elements. Need to stick them together and convert to integer
                
        patientWeight = ''.join(temp_Weight) #this will create one string containing the weight of the patient
        patientWeight = int(patientWeight)
        
        #NOW NEED TO PARSE THE NUMBERS OUT FO THE AGE VARIABLE
        temp_Age = []
        for age_letter in extract_AGE:
            age_test = age_letter.isdigit()
            if age_test == True:
                temp_Age.append(age_letter)
                
        patientAge = ''.join(temp_Age)
        patientAge = int(patientAge)
    
    resetTEST_Button['state'] = DISABLED
    keep_Button['state'] = DISABLED
    root.update()
    
    loadingLabel = Label(page4, text = "LOADING...", font = ('Helvetica', 20), bg = 'gray89', fg = 'midnight blue')
    loadingLabel.place(relx = 0.5, rely = 0.54, anchor = "center")
    root.update()
    
    progressBAR['value'] = 0 #resets it to make sure if they select to do another test that it looks cleaner upon re-arrival at page 4
    root.update()
    
        
    global LEFT_FSR1_NORMALIZED
    global LEFT_FSR2_NORMALIZED
    global LEFT_FSR3_NORMALIZED
        
    global RIGHT_FSR1_NORMALIZED
    global RIGHT_FSR2_NORMALIZED
    global RIGHT_FSR3_NORMALIZED
    
    global LEFT_FSR_TOTAL
    global RIGHT_FSR_TOTAL
        
    global LEFT_XAcceleration_NORMALIZED
    global LEFT_YAcceleration_NORMALIZED
    global LEFT_ZAcceleration_NORMALIZED
        
    global RIGHT_XAcceleration_NORMALIZED
    global RIGHT_YAcceleration_NORMALIZED
    global RIGHT_ZAcceleration_NORMALIZED
        
    global timeVector
        
    #since CSV is generated in here, the data must be read off the serial port as it was transmitted in the prior function
    #the conversion math also needs to be done in here for the FSR bit values which comes from the calibration 
    #remember to tag the file w the randomly generated alphanumeric string from the patient biodata section
        
    DataReceived = False
        
    #DEFINE EMPTY ARRAYS TO BE FILLED W APPEND
        
    #LEFT LEG
    LEFT_XAcceleration = []
    LEFT_YAcceleration = []
    LEFT_ZAcceleration = []
        
    LEFT_FSR1BitValue = []
    LEFT_FSR2BitValue = []
    LEFT_FSR3BitValue = []
        
    #RIGHT LEG
    RIGHT_XAcceleration = []
    RIGHT_YAcceleration = []
    RIGHT_ZAcceleration = []
        
    RIGHT_FSR1BitValue = []
    RIGHT_FSR2BitValue = []
    RIGHT_FSR3BitValue = []
        
    #TIME VECTOR 
    timeVector = []
        
    #WRITE COMMAND TO START READING IN DATA
    serLEFT.flushInput()
    serRIGHT.flushInput()
    time.sleep(1)
        
    serLEFT.write(b'Send_Data') #THIS IS DONE IN HERE AND THEN SAMPLES READ AND SORTED RIGHT AFTER TO PREVENT BUFFER OVERFLOW AS WAS HAPPENING BEFORE
    serRIGHT.write(b'Send_Data') #QUEUE in the serial port can only be so long before overflow occurs and data begins to become corrupted
        
        
    while DataReceived == False:
        leftRAW = serLEFT.readline()
        rightRAW = serRIGHT.readline()
            
        #time.sleep(0.01) #having weird issue where values aren't lining up and not sure if need a delay statement here
            
        if b';' not in leftRAW or b';' not in rightRAW: #OR instead of AND becayse in case of data corruption, this will ensure the data remains the same length for both left and right sides
            #will make it way easier for plotting
            DataReceived = True
            break #breaks out of loop at this point
                
        leftRAWString = str(leftRAW, 'utf-8')
        rightRAWString = str(rightRAW, 'utf-8')
            
        leftSplit = leftRAWString.split(',')
        rightSplit = rightRAWString.split(',')
            
        #data format:
        #1,-3.99,-0.92,8.92,4095,4095,4095,; THIS IS FOR leftRAWString
        #['1', '-3.99', '-0.92', '8.92', '4095', '4095', '4095', ';\r\n'] FORMAT FOR SPLIT VERSION
            
        #split out values based on condition + convert to integers for plotting
        LEFT_X_ACC_FLOAT = float(leftSplit[1])
        LEFT_Y_ACC_FLOAT = float(leftSplit[2])
        LEFT_Z_ACC_FLOAT = float(leftSplit[3])
            
        LEFT_FSR1_INT = int(leftSplit[4])
        LEFT_FSR2_INT = int(leftSplit[5])
        LEFT_FSR3_INT = int(leftSplit[6])
            
        RIGHT_X_ACC_FLOAT = float(rightSplit[1])
        RIGHT_Y_ACC_FLOAT = float(rightSplit[2])
        RIGHT_Z_ACC_FLOAT = float(rightSplit[3])
            
        RIGHT_FSR1_INT = int(rightSplit[4])
        RIGHT_FSR2_INT = int(rightSplit[5])
        RIGHT_FSR3_INT = int(rightSplit[6])
            
        #ALSO SPLIT OUT THE ZEROTH INDEX FROM THE PRINTED LINE AS CONTAINS INDEX VALUE OF RESPECTIVE DATA POINTS
        #will be used for plotting, doesn't matter which side it comes from as both devices are synced
        timeVector_Sample = int(leftSplit[0])
        timeVector.append(timeVector_Sample)
            
            
        #NOW APPEND INTO PROPER ARRAYS
        LEFT_XAcceleration.append(LEFT_X_ACC_FLOAT)
        LEFT_YAcceleration.append(LEFT_Y_ACC_FLOAT)
        LEFT_ZAcceleration.append(LEFT_Z_ACC_FLOAT)
            
        LEFT_FSR1BitValue.append(LEFT_FSR1_INT)
        LEFT_FSR2BitValue.append(LEFT_FSR2_INT)
        LEFT_FSR3BitValue.append(LEFT_FSR3_INT)
            
        RIGHT_XAcceleration.append(RIGHT_X_ACC_FLOAT)
        RIGHT_YAcceleration.append(RIGHT_Y_ACC_FLOAT)
        RIGHT_ZAcceleration.append(RIGHT_Z_ACC_FLOAT)
            
        RIGHT_FSR1BitValue.append(RIGHT_FSR1_INT)
        RIGHT_FSR2BitValue.append(RIGHT_FSR2_INT)
        RIGHT_FSR3BitValue.append(RIGHT_FSR3_INT)
            
        
    #NOW OUTSIDE THE LOOP IS WHERE CAN DO ALL THE CONVERSION MATH
    #REMEMBER NORMALIZING BASED ON PATIENT WEIGHT, the weight entry variable will be in string form and must convert to INT type.
        
    #also need to convert lists from above into numpy arrays so that mathematical transformations can be applied to the data
    #HERE WE WILL USE NUMPY ARRAYS
        
    timeVector = np.array(timeVector)
        
    LEFT_XAcceleration = np.array(LEFT_XAcceleration)
    LEFT_YAcceleration = np.array(LEFT_YAcceleration)
    LEFT_ZAcceleration = np.array(LEFT_ZAcceleration)
        
    RIGHT_XAcceleration = np.array(RIGHT_XAcceleration)
    RIGHT_YAcceleration = np.array(RIGHT_YAcceleration)
    RIGHT_ZAcceleration = np.array(RIGHT_ZAcceleration)
        
    #now the FSR data needs applied mathematical transformations to become useable data
    #THE DERIVED TRANSFORMATION EQUATION FROM MV TO KG IS: Mass (kg) = 60.701*Resistance^-0.625
        
    #first we convert the ADC incoming bit value into mV using mapping function (interpolation)
    #12 bit ADC so bit value ranges from 0-4095 and ESP32 ops on 3.3v (3300 mV)
    LEFT_FSR1_Voltage = np.interp(LEFT_FSR1BitValue, [0, 4095], [1, 3300]) #this also does the converion from list into numpy array
    LEFT_FSR2_Voltage = np.interp(LEFT_FSR2BitValue, [0, 4095], [1, 3300])
    LEFT_FSR3_Voltage = np.interp(LEFT_FSR3BitValue, [0, 4095], [1, 3300]) #IMPORTANT: CHANGED FROM 0-3300 to 1-3300. THIS SOLVED POTENTIAL DIV/0 in force calc below. HAPPENS IF FSR READING SPIKES
        
    RIGHT_FSR1_Voltage = np.interp(RIGHT_FSR1BitValue, [0, 4095], [1, 3300])
    RIGHT_FSR2_Voltage = np.interp(RIGHT_FSR2BitValue, [0, 4095], [1, 3300])
    RIGHT_FSR3_Voltage = np.interp(RIGHT_FSR3BitValue, [0, 4095], [1, 3300])
        
    #now with voltage can apply voltage divider equation to get resistance. This is based on the hardware design
    #(FSRVoltage*10000)/(3301-FSRVoltage) = FSRresistance
    LEFT_FSR1_Resistance = (LEFT_FSR1_Voltage*10000)/(3301 - LEFT_FSR1_Voltage)
    LEFT_FSR2_Resistance = (LEFT_FSR2_Voltage*10000)/(3301 - LEFT_FSR2_Voltage)
    LEFT_FSR3_Resistance = (LEFT_FSR3_Voltage*10000)/(3301 - LEFT_FSR3_Voltage)
        
    RIGHT_FSR1_Resistance = (RIGHT_FSR1_Voltage*10000)/(3301 - RIGHT_FSR1_Voltage)
    RIGHT_FSR2_Resistance = (RIGHT_FSR2_Voltage*10000)/(3301 - RIGHT_FSR2_Voltage)
    RIGHT_FSR3_Resistance = (RIGHT_FSR3_Voltage*10000)/(3301 - RIGHT_FSR3_Voltage)
        
    #now apply derived mathematical expression from calibration procedure: Mass (kg) = 60.701*Resistance^-0.625
    #LEFT_FSR1_Mass = 60.701*LEFT_FSR1_Resistance**-0.625
    #LEFT_FSR2_Mass = 60.701*LEFT_FSR2_Resistance**-0.625
    #LEFT_FSR3_Mass = 60.701*LEFT_FSR3_Resistance**-0.625
        
    #RIGHT_FSR1_Mass = 60.701*RIGHT_FSR1_Resistance**-0.625
    #RIGHT_FSR2_Mass = 60.701*RIGHT_FSR2_Resistance**-0.625
    #RIGHT_FSR3_Mass = 60.701*RIGHT_FSR3_Resistance**-0.625
        
    #also calculate force. THIS IS THE CALIBRATION TRANSFER FUNCTION
    LEFT_FSR1_Force = (GRAVITY*60.701)*LEFT_FSR1_Resistance**-0.625
    LEFT_FSR2_Force = (GRAVITY*60.701)*LEFT_FSR2_Resistance**-0.625
    LEFT_FSR3_Force = (GRAVITY*60.701)*LEFT_FSR3_Resistance**-0.625
        
    RIGHT_FSR1_Force = (GRAVITY*60.701)*RIGHT_FSR1_Resistance**-0.625
    RIGHT_FSR2_Force = (GRAVITY*60.701)*RIGHT_FSR2_Resistance**-0.625
    RIGHT_FSR3_Force = (GRAVITY*60.701)*RIGHT_FSR3_Resistance**-0.625
    
    #BECAUSE THE SENSORS ARE KINDA SHITTY and sometimes a bit value of 0 comes out of the ADC under the right pressure profile:
    #this results in a massive force spike up to about 300N 
    #based on the data sheet the sensors are accurate up to about 20-30N so will cap all values above 30N at 30N before dividing by body weight
    #non linear effects occur after 30N. 
    
    #CAP VALUES HERE
    LEFT_FSR1_Force = np.clip(LEFT_FSR1_Force, a_min = 0, a_max = 30)
    LEFT_FSR2_Force = np.clip(LEFT_FSR2_Force, a_min = 0, a_max = 30)
    LEFT_FSR3_Force = np.clip(LEFT_FSR3_Force, a_min = 0, a_max = 30)
    
    RIGHT_FSR1_Force = np.clip(RIGHT_FSR1_Force, a_min = 0, a_max = 30)
    RIGHT_FSR2_Force = np.clip(RIGHT_FSR2_Force, a_min = 0, a_max = 30)
    RIGHT_FSR3_Force = np.clip(RIGHT_FSR3_Force, a_min = 0, a_max = 30)
        
    #patientWeight at this point in the program is now confirmed to be convertable into a useable integer, but this conversion must still be done here
    BODY_WEIGHT_NORMALIZE = float(patientWeight) #PATIENT WEIGHT NEEDS TO EXIST BY THIS POINT
        
    LEFT_FSR1_NORMALIZED = LEFT_FSR1_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
    LEFT_FSR2_NORMALIZED = LEFT_FSR2_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
    LEFT_FSR3_NORMALIZED = LEFT_FSR3_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
        
    RIGHT_FSR1_NORMALIZED = RIGHT_FSR1_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
    RIGHT_FSR2_NORMALIZED = RIGHT_FSR2_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
    RIGHT_FSR3_NORMALIZED = RIGHT_FSR3_Force/(BODY_WEIGHT_NORMALIZE*GRAVITY)
    
    #CREATE SUMMATION FOR FSR's - just using 1 and 3 for sum plotting so not to throw off the average and have the plots higher weighted towards the toe section
    LEFT_FSR_TOTAL = LEFT_FSR1_NORMALIZED + LEFT_FSR3_NORMALIZED
    RIGHT_FSR_TOTAL = RIGHT_FSR1_NORMALIZED + RIGHT_FSR3_NORMALIZED 

    #also normalize acceleration data based on gravity 
    LEFT_XAcceleration_NORMALIZED = LEFT_XAcceleration/GRAVITY
    LEFT_YAcceleration_NORMALIZED = (-1*LEFT_YAcceleration)/GRAVITY #THIS IS MULTIPLIED BY -1 BECAUSE OF ORIENTATION OF PCB FOR LEFT FOOT
    LEFT_ZAcceleration_NORMALIZED = LEFT_ZAcceleration/GRAVITY
        
    RIGHT_XAcceleration_NORMALIZED = RIGHT_XAcceleration/GRAVITY
    RIGHT_YAcceleration_NORMALIZED = RIGHT_YAcceleration/GRAVITY
    RIGHT_ZAcceleration_NORMALIZED = RIGHT_ZAcceleration/GRAVITY
    #all data is now normalized and ready for plotting
        
    #convert data into pandas data frame to make easier to save as CSV and also convert into table format 
    gait_data = {'LeftFSR_MedialToe': LEFT_FSR1_NORMALIZED, 'LeftFSR_LateralToe': LEFT_FSR2_NORMALIZED, 'LeftFSR_Heel': LEFT_FSR3_NORMALIZED, 'Left_XAcc': LEFT_XAcceleration_NORMALIZED, 'Left_YAcc': LEFT_YAcceleration_NORMALIZED, 'Left_ZAcc': LEFT_ZAcceleration_NORMALIZED, 'RightFSR_MedialToe': RIGHT_FSR1_NORMALIZED, 'RightFSR_LateralToe': RIGHT_FSR2_NORMALIZED, 'RightFSR_Heel': RIGHT_FSR3_NORMALIZED, 'Right_XAcc': RIGHT_XAcceleration_NORMALIZED, 'Right_YAcc': RIGHT_YAcceleration_NORMALIZED, 'Right_ZAcc': RIGHT_ZAcceleration_NORMALIZED}
        
    GAIT_DATA_TABLE = pd.DataFrame(data = gait_data)

    #SUPER IMPORTANT BEFORE WE SAVE DATA, NEED TO KNOW IF THIS IS A NEW USER OR A RETURNING USER
    #THIS WILL BE HANDLED BY A SIMPLE IF STATEMENT

    new_user = emailEntry.get()
    returning_user = login_Entry.get()

    if len(new_user) > 0 and len(returning_user) == 0:
        
        GAIT_DATA_TABLE.to_csv(f'{dir2}/{new_user}_{date_time}_GAITDATA.csv')

    elif len(returning_user) > 0 and len(new_user) == 0:

        GAIT_DATA_TABLE.to_csv(f'{returning_user}_UserData/{returning_user}_RawData/{returning_user}_{date_time}_GAITDATA.csv')

    
    loadingLabel.destroy()
        
    #END OF FUNCTION STUFF
    page4NextButton['state'] = NORMAL
    

keep_Button = Button(page4, text = "SUBMIT", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = keepFunction)
keep_Button.place(relx = 0.2325, rely = 0.46, anchor = "center", height = 40, width = 80)
keep_Button['state'] = DISABLED #so that the data can't be submitted until the collection process has completed in the startTestFunction above


def resetTESTFunction():
    resetTEST_Button['state'] = DISABLED
    keep_Button['state'] = DISABLED
    startTestButton['state'] = NORMAL
    
    #and reset progress bar back to zero just to make the whole thing cleaner 
    progressBAR['value'] = 0


resetTEST_Button = Button(page4, text = "RESET", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = resetTESTFunction)
resetTEST_Button.place(relx = 0.29, rely = 0.46, anchor = "center", height = 40, width = 80)
resetTEST_Button['state'] = DISABLED


#NEXT PAGE AND BACK BUTTONS
def p4NextFunction():
    masterNotebook.select(page5)
    page4NextButton['state'] = DISABLED
    

page4NextButton = Button(page4, text = "VIEW RESULTS", command = p4NextFunction, bg = 'midnight blue', fg = 'ghost white', font = ('Helvetica', 13, 'bold'))
page4NextButton.place(relx = 0.5, rely = 0.60, anchor = "center", height = 40, width = 160)
page4NextButton['state'] = DISABLED
#########################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 5

#section for page3 help button
def p5HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page5_HELP = Button(page5, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p5HELP_FUNCTION)
page5_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)

def unlockDataFunction():
    
    global select_sensor_label
    
    global left_sensor_list
    global left_confirm_sensor_button
    
    global right_sensor_list
    global right_confirm_sensor_button
    
    #WITHIN HERE CREATE DROP DOWN MENU TO SELECT WHICH FSR (MEDIAL OR LATERAL TOE) TO USE FOR CALCULATING PARAMETERS
    select_sensor_label = Label(page5, text = "Select Toe Sensor for Parameter Calculation", font = ('Helvetica', 12), fg = 'midnight blue', bg = 'gray89')
    select_sensor_label.place(relx = 0.5, rely = 0.75, anchor = 'center')
    
    left_sensor_variable = StringVar(page5)
    left_sensor_variable.set('Medial')
    left_sensor_list = OptionMenu(page5, left_sensor_variable, "Medial", "Lateral")
    left_sensor_list.config(bg = 'ghost white')
    left_sensor_list.place(relx = 0.465, rely = 0.775, anchor = "center")
    
    def LEFTsensorFunction():
        
        global LEFT_FSR1_NORMALIZED
        global LEFT_FSR_TOTAL
        
        left_confirm_sensor_button['state'] = DISABLED
        right_confirm_sensor_button['state'] = NORMAL
        
        left_sensor_choice = left_sensor_variable.get()
        
        if left_sensor_choice == "Medial":
            pass
        else:
            LEFT_FSR1_NORMALIZED = LEFT_FSR2_NORMALIZED #very hacky and not a good fix but idgaf at this point
            LEFT_FSR_TOTAL = LEFT_FSR2_NORMALIZED + LEFT_FSR3_NORMALIZED
        
    left_confirm_sensor_button = Button(page5, text = "confirm left", font = 'Helvetica', fg = 'midnight blue', bg = 'gray70', command = LEFTsensorFunction)
    left_confirm_sensor_button.place(relx = 0.535, rely = 0.775, anchor = 'center')
    
    right_sensor_variable = StringVar(page5)
    right_sensor_variable.set('Medial')
    right_sensor_list = OptionMenu(page5, right_sensor_variable, "Medial", "Lateral")
    right_sensor_list.config(bg = 'ghost white')
    right_sensor_list.place(relx = 0.465, rely = 0.81, anchor = "center")
    
    def RIGHTsensorFunction():
        
        global RIGHT_FSR1_NORMALIZED
        global RIGHT_FSR_TOTAL
        
        right_confirm_sensor_button['state'] = DISABLED
        #now unlock temporal params calculation button
        gait_parameters_button['state'] = NORMAL
        right_sensor_choice = right_sensor_variable.get()
        
        if right_sensor_choice == "Medial": #now from this parameters should be calculated using medial and gait cycles using medial 
            pass #going to do a hacky patch and set FSR1 = FSR2 if lateral selected, if medial selected can do nothing cause program was written assuming medial would be used
        else: #from this parameters should be calc using lateral and gait cycles using lateral
            RIGHT_FSR1_NORMALIZED = RIGHT_FSR2_NORMALIZED
            RIGHT_FSR_TOTAL = RIGHT_FSR2_NORMALIZED + RIGHT_FSR3_NORMALIZED
    
    right_confirm_sensor_button = Button(page5, text = "confirm right", font = 'Helvetica', fg = 'midnight blue', bg = 'gray70', command = RIGHTsensorFunction)
    right_confirm_sensor_button.place(relx = 0.535, rely = 0.81, anchor = 'center')
    right_confirm_sensor_button['state'] = DISABLED
    
    global refreshPlot_button
    global p5_canvas
    global p5_toolbar
    global LTM_button
    global LTL_button
    global LH_button
    global LTotal_button
    global RTM_button
    global RTL_button
    global RH_button
    global RTotal_button
    
    global Legend1_Label
    global dynamic_Label_LEFT
    global dynamic_Label_RIGHT
    
    
    #create plot refresh button
    def refreshFunction(): #in here create new instance of fresh plot
        
        global p5_canvas #so that it can be destroyed
        global p5_toolbar
        global LTM_button
        global LTL_button
        global LH_button
        global LTotal_button
        global RTM_button
        global RTL_button
        global RH_button
        global RTotal_button
        
        global Legend1_Label
        global dynamic_Label_LEFT
        global dynamic_Label_RIGHT
        
        #now destroy the old one
        p5_canvas.get_tk_widget().destroy()
        p5_toolbar.destroy()
        #DESTROY ALL BUTTONS 
        LTM_button.destroy()
        LTL_button.destroy()
        LH_button.destroy()
        LTotal_button.destroy()
        
        RTM_button.destroy()
        RTL_button.destroy()
        RH_button.destroy()
        RTotal_button.destroy()
        
        #ALSO DESTROY THE LEGENDS
        Legend1_Label.destroy()
        dynamic_Label_LEFT.destroy()
        dynamic_Label_RIGHT.destroy()
        
        #now create new canvas
        page5_figure = Figure(figsize = (12,6), dpi = 100)
        p5_graph_variable = page5_figure.add_subplot(111)
        p5_canvas = FigureCanvasTkAgg(page5_figure, page5)
        p5_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
        p5_graph_variable.set_xlabel('TIME [seconds]')
        p5_graph_variable.set_ylabel('FSR [% Body Weight]')
        p5_toolbar = NavigationToolbar2Tk(p5_canvas, page5)
        p5_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
        
        #ABOUT TO GET CRAZY IN HERE
        #UNFORTUNATELY even though the p5 plot is recreated in here, the old buttons aren't updated with this new instance of this variable
        #the only fix I know how to do is to recreate the buttons overlayed on the old ones and redefined in this function to allow for continuous re-plotting
        #should probably destroy the buttons as well as the old plot and labels before recreating
        
        #RECREATE THE BUTTON FUNCTIONS
        def LTM_switch():
    
            global LTM_on
    
            if LTM_on == False:
                LTM_on = True
                LTM_button.config(image = ON)
                LTM_button['state'] = DISABLED
                #and now plot appropriate data set
                p5_graph_variable.plot(TIME, (LEFT_FSR1_NORMALIZED*100)*250/3, color = "red", linestyle = "dashdot") #note the *100 to make it BW percentage
                p5_canvas.draw()
            else:
                LTM_button.config(image = OFF)
                LTM_on = False

        def LTL_switch():
    
            global LTL_on
    
            if LTL_on == False:
                LTL_on = True
                LTL_button.config(image = ON)
                LTL_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (LEFT_FSR2_NORMALIZED*100)*250/3, color = "red", linestyle = "dashed")
                p5_canvas.draw()
            else:
                LTL_button.config(image = OFF)
                LTL_on = False

        def LH_switch():
    
            global LH_on
    
            if LH_on == False:
                LH_on = True
                LH_button.config(image = ON)
                LH_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (LEFT_FSR3_NORMALIZED*100)*250/3, color = "red", linestyle = "dotted")
                p5_canvas.draw()
            else:
                LH_button.config(image = OFF)
                LH_on = False

        def LTotal_switch():
    
            global LTotal_on
    
            if LTotal_on == False:
                LTotal_on = True
                LTotal_button.config(image = ON)
                LTotal_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (LEFT_FSR_TOTAL*100)*250/3, color = "red", linestyle = "solid")
                p5_canvas.draw()
            else:
                LTotal_button.config(image = OFF)
                LTotal_on = False

        #RIGHT
        def RTM_switch():
    
            global RTM_on
    
            if RTM_on == False:
                RTM_on = True
                RTM_button.config(image = ON)
                RTM_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (RIGHT_FSR1_NORMALIZED*100)*250/3, color = "blue", linestyle = "dashdot")
                p5_canvas.draw()
            else:
                RTM_button.config(image = OFF)
                RTM_on = False

        def RTL_switch():
    
            global RTL_on
    
            if RTL_on == False:
                RTL_on = True
                RTL_button.config(image = ON)
                RTL_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (RIGHT_FSR2_NORMALIZED*100)*250/3, color = "blue", linestyle = "dashed")
                p5_canvas.draw()
            else:
                RTL_button.config(image = OFF)
                RTL_on = False

        def RH_switch():
    
            global RH_on
    
            if RH_on == False:
                RH_on = True
                RH_button.config(image = ON)
                RH_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (RIGHT_FSR3_NORMALIZED*100)*250/3, color = "blue", linestyle = "dotted")
                p5_canvas.draw()
            else:
                RH_button.config(image = OFF)
                RH_on = False

        def RTotal_switch():
    
            global RTotal_on
    
            if RTotal_on == False:
                RTotal_on = True
                RTotal_button.config(image = ON)
                RTotal_button['state'] = DISABLED
            
                p5_graph_variable.plot(TIME, (RIGHT_FSR_TOTAL*100)*250/3, color = "blue", linestyle = "solid")
                p5_canvas.draw()
            else:
                RTotal_button.config(image = OFF)
                RTotal_on = False
        
        #NEED TO RECREATE THE TOGGLE SWITCH BUTTONS
        LTM_button = Button(page5, image = OFF, bd = 0, command = LTM_switch)
        LTM_button.place(relx = 0.1, rely = 0.25, anchor = "center")

        LTL_button = Button(page5, image = OFF, bd = 0, command = LTL_switch)
        LTL_button.place(relx = 0.1, rely = 0.35, anchor = "center")

        LH_button = Button(page5, image = OFF, bd = 0, command = LH_switch)
        LH_button.place(relx = 0.1, rely = 0.45, anchor = "center")

        LTotal_button = Button(page5, image = OFF, bd = 0, command = LTotal_switch)
        LTotal_button.place(relx = 0.1, rely = 0.55, anchor = "center")

        RTM_button = Button(page5, image = OFF, bd = 0, command = RTM_switch)
        RTM_button.place(relx = 0.9, rely = 0.25, anchor = "center")

        RTL_button = Button(page5, image = OFF, bd = 0, command = RTL_switch)
        RTL_button.place(relx = 0.9, rely = 0.35, anchor = "center")

        RH_button = Button(page5, image = OFF, bd = 0, command = RH_switch)
        RH_button.place(relx = 0.9, rely = 0.45, anchor = "center")

        RTotal_button = Button(page5, image = OFF, bd = 0, command = RTotal_switch)
        RTotal_button.place(relx = 0.9, rely = 0.55, anchor = "center")
        
        #now have to toggle off all 8 switches
        global LTM_on
        global LTL_on
        global LH_on
        global LTotal_on
        global RTM_on
        global RTL_on
        global RH_on
        global RTotal_on
        
        LTM_button.config(image = OFF)
        LTM_on = False
        LTM_button['state'] = NORMAL
        
        LTL_button.config(image = OFF)
        LTL_on = False
        LTL_button['state'] = NORMAL
        
        LH_button.config(image = OFF)
        LH_on = False
        LH_button['state'] = NORMAL
        
        LTotal_button.config(image = OFF)
        LTotal_on = False
        LTotal_button['state'] = NORMAL
        
        RTM_button.config(image = OFF)
        RTM_on = False
        RTM_button['state'] = NORMAL
        
        RTL_button.config(image = OFF)
        RTL_on = False
        RTL_button['state'] = NORMAL
        
        RH_button.config(image = OFF)
        RH_on = False
        RH_button['state'] = NORMAL
        
        RTotal_button.config(image = OFF)
        RTotal_on = False
        RTotal_button['state'] = NORMAL
        
        #also in here have to recreate the static and dynamic labels 
        Legend1_Label = Label(page5, text = "-.-. TOE MEDIAL \n --- TOE LATERAL \n .... HEEL \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        Legend1_Label.place(relx = 0.752, rely = 0.155, anchor = "w")
        
        dynamic_Label_LEFT = Label(page5, text = f" LEFT ({left_leg_status}) ", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_LEFT.place(relx = 0.23, rely = 0.14, anchor = "center")
    
        dynamic_Label_RIGHT = Label(page5, text = f"RIGHT ({right_leg_status})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_RIGHT.place(relx = 0.23, rely = 0.16, anchor = "center")
          
        
    refreshPlot_button = Button(page5, text = "REFRESH PLOT", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = refreshFunction)
    refreshPlot_button.place(relx = 0.5, rely = 0.1, anchor = "center")
    
    
    global amputation_SIDE_forPlotting
    global left_leg_status
    global right_leg_status
    global TIME
    
    global LTM_label
    global LTL_label
    global LH_label
    global LTotal_label
    
    global RTM_label
    global RTL_label
    global RH_label
    global RTotal_label
    
    submitAmputationSIDEButton['state'] = DISABLED
    
    #HERE WANT TO PULL AMPUTATION SIDE TO CREATE CUSTOMIZED PLOT LEGENDS BASED ON THE PATIENT 
    #there are 4 cases
    
    amputation_String = str(patientAmputation) #need to convert list from page 2 into a string 

    if "Left" in amputation_String and "Right" not in amputation_String:
        amputation_SIDE_forPlotting = "LEFT"
    elif "Right" in amputation_String and "Left" not in amputation_String:
        amputation_SIDE_forPlotting = "RIGHT"
    elif "Left" in amputation_String and "Right" in amputation_String:
        amputation_SIDE_forPlotting = "BOTH"
    else:
        amputation_SIDE_forPlotting = "NEITHER"
    
    #CREATE INTERPOLATED ARRAY FOR TIME IN SECONDS CAUSE THAT MAKES WAY MORE SENSE THAN WHAT I WAS DOING BEFORE :()
    TIME = np.interp(timeVector, [0, 2999], [0, 30]) #THIS IS THE X AXIS FOR EVERYTHING
    
    ##NOW HERE WE GENERATE PLOTS USING MATPLOTLIB LIBRARY
    page5_figure = Figure(figsize = (12,6), dpi = 100)
    p5_graph_variable = page5_figure.add_subplot(111)
    #p5_graph_variable.plot(TIME, LEFT_FSR1_NORMALIZED)
    
    #f = p5_graph_variable.plot([1,2,3], [1,2,3])
    
    p5_canvas = FigureCanvasTkAgg(page5_figure, page5)
    #p5_canvas.draw()
    p5_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
    
    #TO ADD MULTIPLE PLOTS TO SAME CHART, CAN DO ANOTHER p5_graph_variable.plot() and then must follow up with p5_canvas.draw() to add the data to the chart 
    
    #add AXIS LABELS 
    p5_graph_variable.set_xlabel('TIME [seconds]')
    p5_graph_variable.set_ylabel('FSR [% Body Weight]')
    #p5_graph_variable.set_title('')
    
    p5_toolbar = NavigationToolbar2Tk(p5_canvas, page5)
    p5_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
    
    #CREATE hacked LEGEND USING LABEL I GUESS
    #define static label
    Legend1_Label = Label(page5, text = "-.-. TOE MEDIAL \n --- TOE LATERAL \n .... HEEL \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    Legend1_Label.place(relx = 0.752, rely = 0.155, anchor = "w")
    
    #define dynamic label
    #based on user input, this one is gonna suck
    if amputation_SIDE_forPlotting == "LEFT":
        left_leg_status = "Prosthesis"
        right_leg_status = "Intact"
    elif amputation_SIDE_forPlotting == "RIGHT":
        left_leg_status = "Intact"
        right_leg_status = "Prosthesis"
    elif amputation_SIDE_forPlotting == "BOTH":
        left_leg_status = "Prosthesis"
        right_leg_status = "Prosthesis"
    else:
        left_leg_status = "Intact"
        right_leg_status = "Intact"
        
    dynamic_Label_LEFT = Label(page5, text = f" LEFT ({left_leg_status}) ", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_LEFT.place(relx = 0.23, rely = 0.14, anchor = "center")
    
    dynamic_Label_RIGHT = Label(page5, text = f"RIGHT ({right_leg_status})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_RIGHT.place(relx = 0.23, rely = 0.16, anchor = "center")
    
    #CREATE TOGGLE SWITCHES TO DISPLAY CORRECT DATA SETS ON GRAPH (this will be hard probably)
    #using imported images overlayed on buttons for simulation of a toggle switch

    #DEFINE TOGGLE IMAGES
    ON = ImageTk.PhotoImage(Image.open("images/ON.jpg"))
    OFF = ImageTk.PhotoImage(Image.open("images/OFF.jpg"))

    #DEFINE BUTTON STATE BOOLEANS
    global LTM_on
    global LTL_on
    global LH_on
    global LTotal_on

    global RTM_on
    global RTL_on
    global RH_on
    global RTotal_on

    LTM_on = False
    LTL_on = False
    LH_on = False
    LTotal_on = False

    RTM_on = False
    RTL_on = False
    RH_on = False
    RTotal_on = False

    #DEFINE CALLABLE FUNCTIONS
    #LEFT
    def LTM_switch():
    
        global LTM_on
    
        if LTM_on == False:
            LTM_on = True
            LTM_button.config(image = ON)
            LTM_button['state'] = DISABLED
            #and now plot appropriate data set
            p5_graph_variable.plot(TIME, (LEFT_FSR1_NORMALIZED*100)*250/3, color = "red", linestyle = "dashdot")
            p5_canvas.draw()
        else:
            LTM_button.config(image = OFF)
            LTM_on = False

    def LTL_switch():
    
        global LTL_on
    
        if LTL_on == False:
            LTL_on = True
            LTL_button.config(image = ON)
            LTL_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (LEFT_FSR2_NORMALIZED*100)*250/3, color = "red", linestyle = "dashed")
            p5_canvas.draw()
        else:
            LTL_button.config(image = OFF)
            LTL_on = False

    def LH_switch():
    
        global LH_on
    
        if LH_on == False:
            LH_on = True
            LH_button.config(image = ON)
            LH_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (LEFT_FSR3_NORMALIZED*100)*250/3, color = "red", linestyle = "dotted")
            p5_canvas.draw()
        else:
            LH_button.config(image = OFF)
            LH_on = False

    def LTotal_switch():
    
        global LTotal_on
    
        if LTotal_on == False:
            LTotal_on = True
            LTotal_button.config(image = ON)
            LTotal_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (LEFT_FSR_TOTAL*100)*250/3, color = "red", linestyle = "solid")
            p5_canvas.draw()
        else:
            LTotal_button.config(image = OFF)
            LTotal_on = False

    #RIGHT
    def RTM_switch():
    
        global RTM_on
    
        if RTM_on == False:
            RTM_on = True
            RTM_button.config(image = ON)
            RTM_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (RIGHT_FSR1_NORMALIZED*100)*250/3, color = "blue", linestyle = "dashdot")
            p5_canvas.draw()
        else:
            RTM_button.config(image = OFF)
            RTM_on = False

    def RTL_switch():
    
        global RTL_on
    
        if RTL_on == False:
            RTL_on = True
            RTL_button.config(image = ON)
            RTL_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (RIGHT_FSR2_NORMALIZED*100)*250/3, color = "blue", linestyle = "dashed")
            p5_canvas.draw()
        else:
            RTL_button.config(image = OFF)
            RTL_on = False

    def RH_switch():
    
        global RH_on
    
        if RH_on == False:
            RH_on = True
            RH_button.config(image = ON)
            RH_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (RIGHT_FSR3_NORMALIZED*100)*250/3, color = "blue", linestyle = "dotted")
            p5_canvas.draw()
        else:
            RH_button.config(image = OFF)
            RH_on = False

    def RTotal_switch():
    
        global RTotal_on
    
        if RTotal_on == False:
            RTotal_on = True
            RTotal_button.config(image = ON)
            RTotal_button['state'] = DISABLED
            
            p5_graph_variable.plot(TIME, (RIGHT_FSR_TOTAL*100)*250/3, color = "blue", linestyle = "solid")
            p5_canvas.draw()
        else:
            RTotal_button.config(image = OFF)
            RTotal_on = False

    LTM_button = Button(page5, image = OFF, bd = 0, command = LTM_switch)
    LTM_button.place(relx = 0.1, rely = 0.25, anchor = "center")

    LTL_button = Button(page5, image = OFF, bd = 0, command = LTL_switch)
    LTL_button.place(relx = 0.1, rely = 0.35, anchor = "center")

    LH_button = Button(page5, image = OFF, bd = 0, command = LH_switch)
    LH_button.place(relx = 0.1, rely = 0.45, anchor = "center")

    LTotal_button = Button(page5, image = OFF, bd = 0, command = LTotal_switch)
    LTotal_button.place(relx = 0.1, rely = 0.55, anchor = "center")

    RTM_button = Button(page5, image = OFF, bd = 0, command = RTM_switch)
    RTM_button.place(relx = 0.9, rely = 0.25, anchor = "center")

    RTL_button = Button(page5, image = OFF, bd = 0, command = RTL_switch)
    RTL_button.place(relx = 0.9, rely = 0.35, anchor = "center")

    RH_button = Button(page5, image = OFF, bd = 0, command = RH_switch)
    RH_button.place(relx = 0.9, rely = 0.45, anchor = "center")

    RTotal_button = Button(page5, image = OFF, bd = 0, command = RTotal_switch)
    RTotal_button.place(relx = 0.9, rely = 0.55, anchor = "center")

    #CREATE LABELS
    LTM_label = Label(page5, text = "FSR - LEFT MEDIAL TOE:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    LTM_label.place(relx = 0.1, rely = 0.2, anchor = "center")
    
    LTL_label = Label(page5, text = "FSR - LEFT LATERAL TOE:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    LTL_label.place(relx = 0.1, rely = 0.3, anchor = "center")
    
    LH_label = Label(page5, text = "FSR - LEFT HEEL:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    LH_label.place(relx = 0.1, rely = 0.4, anchor = "center")
    
    LTotal_label = Label(page5, text = "FSR - LEFT FOOT TOTAL:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    LTotal_label.place(relx = 0.1, rely = 0.5, anchor = "center")
    
    RTM_label = Label(page5, text = "FSR - RIGHT MEDIAL TOE:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    RTM_label.place(relx = 0.9, rely = 0.2, anchor = "center")
    
    RTL_label = Label(page5, text = "FSR - RIGHT LATERAL TOE:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    RTL_label.place(relx = 0.9, rely = 0.3, anchor = "center")
    
    RH_label = Label(page5, text = "FSR - RIGHT HEEL:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    RH_label.place(relx = 0.9, rely = 0.4, anchor = "center")
    
    RTotal_label = Label(page5, text = "FSR - RIGHT FOOT TOTAL:", font = ('Helvetica', 13, 'bold'), bg = 'gray89', fg = 'midnight blue')
    RTotal_label.place(relx = 0.9, rely = 0.5, anchor = "center")

submitAmputationSIDEButton = Button(page5, text = "DISPLAY FSR DATA", font = ('Helvetica', 13, 'bold'), bg = 'green2', fg = 'ghost white', command = unlockDataFunction)
submitAmputationSIDEButton.place(relx = 0.5, rely = 0.05, anchor = "center")
#######################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 6
#ACCELERATION PLOTTING PAGE
def unlockAcceleration():
    
    ####HERE IMPORT IN ACCELERATION DATA TO BE USED - THIS WILL BE THE FULL 30 SECONDS OF DATA FROM THE TEST
    
    #import in raw unfiltered data (already normalized in g force)
    LEFT_YAcceleration_NORMALIZED  #FORWARD DIRECTION (already divided by gravity)
    LEFT_XAcceleration_NORMALIZED
    
    RIGHT_YAcceleration_NORMALIZED
    RIGHT_XAcceleration_NORMALIZED
    
    #design digital filter again
    order_0 = 2 #decided upon order of the butterworth filter
    sample_frequency_0 = 100 #COMES FROM THE SENSOR SAMPLE RATE WHICH IS 100Hz
    nyquist_frequency_0 = sample_frequency_0/2
    cutoff_frequency_0 = 3.5 #this in in HZ and was decided upon based on the results of the FFT (check the appropriate MATLAB script)
    
    Ws_0 = cutoff_frequency_0/nyquist_frequency_0
    
    bb, aa = signal.butter(order_0, Ws_0, btype = 'low') #LOW PASS FILTER
    
    #now filter raw data
    left_horizontal_acceleration_filtered = signal.filtfilt(bb, aa, LEFT_YAcceleration_NORMALIZED)
    left_vertical_acceleration_filtered = signal.filtfilt(bb, aa, LEFT_XAcceleration_NORMALIZED)
    left_sum_acceleration_filtered = left_horizontal_acceleration_filtered + left_vertical_acceleration_filtered
    
    right_horizontal_acceleration_filtered = signal.filtfilt(bb, aa, RIGHT_YAcceleration_NORMALIZED)
    right_vertical_acceleration_filtered = signal.filtfilt(bb, aa, RIGHT_XAcceleration_NORMALIZED)
    right_sum_acceleration_filtered = right_horizontal_acceleration_filtered + right_vertical_acceleration_filtered
    
    global refresh_Acceleration_button
    global p6_canvas
    global p6_toolbar
    global L_vertical_button
    global L_horizontal_button
    global L_Total_button
    global R_vertical_button
    global R_horizontal_button
    global R_Total_button
    
    global Legend1_Label_IMU
    global dynamic_Label_LEFT_IMU
    global dynamic_Label_RIGHT_IMU
    
    
    #create plot refresh button
    def refreshAcceleration(): #in here create new instance of fresh plot
        
        global p6_canvas #so that it can be destroyed
        global p6_toolbar
        global L_vertical_button
        global L_horizontal_button
        global L_Total_button
        global R_vertical_button
        global R_horizontal_button
        global R_Total_button
        
        global Legend1_Label_IMU
        global dynamic_Label_LEFT_IMU
        global dynamic_Label_RIGHT_IMU
        
        #now destroy the old one
        p6_canvas.get_tk_widget().destroy()
        p6_toolbar.destroy()
        #DESTROY ALL BUTTONS 
        L_vertical_button.destroy()
        L_horizontal_button.destroy()
        L_Total_button.destroy()
        
        R_vertical_button.destroy()
        R_horizontal_button.destroy()
        R_Total_button.destroy()
        
        #ALSO DESTROY THE LEGENDS
        Legend1_Label_IMU.destroy()
        dynamic_Label_LEFT_IMU.destroy()
        dynamic_Label_RIGHT_IMU.destroy()
        
        #now create new canvas
        page6_figure = Figure(figsize = (12,6), dpi = 100)
        p6_graph_variable = page6_figure.add_subplot(111)
        p6_canvas = FigureCanvasTkAgg(page6_figure, page6)
        p6_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
        p6_graph_variable.set_xlabel('TIME [seconds]')
        p6_graph_variable.set_ylabel('Acceleration [g]')
        p6_toolbar = NavigationToolbar2Tk(p6_canvas, page6)
        p6_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
        
        #ABOUT TO GET CRAZY IN HERE
        #UNFORTUNATELY even though the p5 plot is recreated in here, the old buttons aren't updated with this new instance of this variable
        #the only fix I know how to do is to recreate the buttons overlayed on the old ones and redefined in this function to allow for continuous re-plotting
        #should probably destroy the buttons as well as the old plot and labels before recreating
        
        #RECREATE THE BUTTON FUNCTIONS
        def L_vertical_SWITCH():
    
            global L_vertical_on
    
            if L_vertical_on == False:
                L_vertical_on = True
                L_vertical_button.config(image = ON_IMU)
                L_vertical_button['state'] = DISABLED
                #and now plot appropriate data set
                p6_graph_variable.plot(TIME_accel, left_vertical_acceleration_filtered, color = "red", linestyle = "dotted")
                p6_canvas.draw()
            else:
                L_vertical_button.config(image = OFF_IMU)
                L_vertical_on = False

        def L_horizontal_SWITCH():
    
            global L_horizontal_on
    
            if L_horizontal_on == False:
                L_horizontal_on = True
                L_horizontal_button.config(image = ON_IMU)
                L_horizontal_button['state'] = DISABLED
            
                p6_graph_variable.plot(TIME_accel, left_horizontal_acceleration_filtered, color = "red", linestyle = "dashed")
                p6_canvas.draw()
            else:
                L_horizontal_button.config(image = OFF_IMU)
                L_horizontal_on = False

        def L_Total_SWITCH():
    
            global L_Total_on
    
            if L_Total_on == False:
                L_Total_on = True
                L_Total_button.config(image = ON_IMU)
                L_Total_button['state'] = DISABLED
            
                p6_graph_variable.plot(TIME_accel, left_sum_acceleration_filtered, color = "red", linestyle = "solid")
                p6_canvas.draw()
            else:
                L_Total_button.config(image = OFF_IMU)
                L_Total_on = False

        #RIGHT
        def R_vertical_SWITCH():
    
            global R_vertical_on
    
            if R_vertical_on == False:
                R_vertical_on = True
                R_vertical_button.config(image = ON_IMU)
                R_vertical_button['state'] = DISABLED
            
                p6_graph_variable.plot(TIME_accel, right_vertical_acceleration_filtered, color = "blue", linestyle = "dotted")
                p6_canvas.draw()
            else:
                R_vertical_button.config(image = OFF_IMU)
                R_vertical_on = False

        def R_horizontal_SWITCH():
    
            global R_horizontal_on
    
            if R_horizontal_on == False:
                R_horizontal_on = True
                R_horizontal_button.config(image = ON_IMU)
                R_horizontal_button['state'] = DISABLED
            
                p6_graph_variable.plot(TIME_accel, right_horizontal_acceleration_filtered, color = "blue", linestyle = "dashed")
                p6_canvas.draw()
            else:
                R_horizontal_button.config(image = OFF_IMU)
                R_horizontal_on = False

        def R_Total_SWITCH():
    
            global R_Total_on
    
            if R_Total_on == False:
                R_Total_on = True
                R_Total_button.config(image = ON_IMU)
                R_Total_button['state'] = DISABLED
            
                p6_graph_variable.plot(TIME_accel, right_sum_acceleration_filtered, color = "blue", linestyle = "solid")
                p6_canvas.draw()
            else:
                R_Total_button.config(image = OFF_IMU)
                R_Total_on = False
        
        #NEED TO RECREATE THE TOGGLE SWITCH BUTTONS
        L_vertical_button = Button(page6, image = OFF_IMU, bd = 0, command = L_vertical_SWITCH)
        L_vertical_button.place(relx = 0.1, rely = 0.25, anchor = "center")

        L_horizontal_button = Button(page6, image = OFF_IMU, bd = 0, command = L_horizontal_SWITCH)
        L_horizontal_button.place(relx = 0.1, rely = 0.35, anchor = "center")

        L_Total_button = Button(page6, image = OFF_IMU, bd = 0, command = L_Total_SWITCH)
        L_Total_button.place(relx = 0.1, rely = 0.45, anchor = "center")

        R_vertical_button = Button(page6, image = OFF_IMU, bd = 0, command = R_vertical_SWITCH)
        R_vertical_button.place(relx = 0.9, rely = 0.25, anchor = "center")

        R_horizontal_button = Button(page6, image = OFF_IMU, bd = 0, command = R_horizontal_SWITCH)
        R_horizontal_button.place(relx = 0.9, rely = 0.35, anchor = "center")

        R_Total_button = Button(page6, image = OFF_IMU, bd = 0, command = R_Total_SWITCH)
        R_Total_button.place(relx = 0.9, rely = 0.45, anchor = "center")
        
        #now have to toggle off all 8 switches
        global L_vertical_on
        global L_horizontal_on
        global L_Total_on

        global R_vertical_on
        global R_horizontal_on
        global R_Total_on
        
        L_vertical_button.config(image = OFF_IMU)
        L_vertical_on = False
        L_vertical_button['state'] = NORMAL
        
        L_horizontal_button.config(image = OFF_IMU)
        L_horizontal_on = False
        L_horizontal_button['state'] = NORMAL
        
        L_Total_button.config(image = OFF_IMU)
        L_Total_on = False
        L_Total_button['state'] = NORMAL
        
        R_vertical_button.config(image = OFF_IMU)
        R_vertical_on = False
        R_vertical_button['state'] = NORMAL
        
        R_horizontal_button.config(image = OFF_IMU)
        R_horizontal_on = False
        R_horizontal_button['state'] = NORMAL
        
        R_Total_button.config(image = OFF_IMU)
        R_Total_on = False
        R_Total_button['state'] = NORMAL
        
        #also in here have to recreate the static and dynamic labels 
        Legend1_Label_IMU = Label(page6, text = ".... VERTICAL ACCELERATION \n --- HORIZONTAL ACCELERATION \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        Legend1_Label_IMU.place(relx = 0.695, rely = 0.155, anchor = "w")
        
        dynamic_Label_LEFT_IMU = Label(page6, text = f" LEFT ({left_leg_status_IMU}) ", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_LEFT_IMU.place(relx = 0.23, rely = 0.14, anchor = "center")
    
        dynamic_Label_RIGHT_IMU = Label(page6, text = f"RIGHT ({right_leg_status_IMU})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_RIGHT_IMU.place(relx = 0.23, rely = 0.16, anchor = "center")
          
        
    refresh_Acceleration_button = Button(page6, text = "REFRESH PLOT", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = refreshAcceleration)
    refresh_Acceleration_button.place(relx = 0.5, rely = 0.1, anchor = "center")
    
    
    global amputation_SIDE_ACCELERATION
    global left_leg_status_IMU
    global right_leg_status_IMU
    global TIME_accel
    
    global L_vertical_label
    global L_horizontal_label
    global L_Total_label
    
    global R_vertical_label
    global R_horizontal_label
    global R_Total_label
    
    acceleration_plot_button['state'] = DISABLED
    
    #HERE WANT TO PULL AMPUTATION SIDE TO CREATE CUSTOMIZED PLOT LEGENDS BASED ON THE PATIENT 
    #there are 4 cases
    
    amputation_String_acceleration_plots = str(patientAmputation) #need to convert list from page 2 into a string 

    if "Left" in amputation_String_acceleration_plots and "Right" not in amputation_String_acceleration_plots:
        amputation_SIDE_ACCELERATION = "LEFT"
    elif "Right" in amputation_String_acceleration_plots and "Left" not in amputation_String_acceleration_plots:
        amputation_SIDE_ACCELERATION = "RIGHT"
    elif "Left" in amputation_String_acceleration_plots and "Right" in amputation_String_acceleration_plots:
        amputation_SIDE_ACCELERATION = "BOTH"
    else:
        amputation_SIDE_ACCELERATION = "NEITHER"
    
    #CREATE INTERPOLATED ARRAY FOR TIME IN SECONDS CAUSE THAT MAKES WAY MORE SENSE THAN WHAT I WAS DOING BEFORE :()
    TIME_accel = np.interp(timeVector, [0, 2999], [0, 30]) #THIS IS THE X AXIS FOR EVERYTHING
    
    ##NOW HERE WE GENERATE PLOTS USING MATPLOTLIB LIBRARY
    page6_figure = Figure(figsize = (12,6), dpi = 100)
    p6_graph_variable = page6_figure.add_subplot(111)
    #p5_graph_variable.plot(TIME, LEFT_FSR1_NORMALIZED)
    
    #f = p5_graph_variable.plot([1,2,3], [1,2,3])
    
    p6_canvas = FigureCanvasTkAgg(page6_figure, page6)
    #p5_canvas.draw()
    p6_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
    
    #TO ADD MULTIPLE PLOTS TO SAME CHART, CAN DO ANOTHER p5_graph_variable.plot() and then must follow up with p5_canvas.draw() to add the data to the chart 
    
    #add AXIS LABELS 
    p6_graph_variable.set_xlabel('TIME [seconds]')
    p6_graph_variable.set_ylabel('Acceleration [g]')
    #p5_graph_variable.set_title('')
    
    p6_toolbar = NavigationToolbar2Tk(p6_canvas, page6)
    p6_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
    
    #CREATE hacked LEGEND USING LABEL I GUESS
    #define static label
    Legend1_Label_IMU = Label(page6, text = ".... VERTICAL ACCELERATION \n --- HORIZONTAL ACCELERATION \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    Legend1_Label_IMU.place(relx = 0.695, rely = 0.155, anchor = "w")
    
    #define dynamic label
    #based on user input, this one is gonna suck
    if amputation_SIDE_ACCELERATION == "LEFT":
        left_leg_status_IMU = "Prosthesis"
        right_leg_status_IMU = "Intact"
    elif amputation_SIDE_ACCELERATION == "RIGHT":
        left_leg_status_IMU = "Intact"
        right_leg_status_IMU = "Prosthesis"
    elif amputation_SIDE_ACCELERATION == "BOTH":
        left_leg_status_IMU = "Prosthesis"
        right_leg_status_IMU = "Prosthesis"
    else:
        left_leg_status_IMU = "Intact"
        right_leg_status_IMU = "Intact"
        
    dynamic_Label_LEFT_IMU = Label(page6, text = f"LEFT ({left_leg_status_IMU})", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_LEFT_IMU.place(relx = 0.23, rely = 0.14, anchor = "center")
    
    dynamic_Label_RIGHT_IMU = Label(page6, text = f"RIGHT ({right_leg_status_IMU})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_RIGHT_IMU.place(relx = 0.23, rely = 0.16, anchor = "center")
    
    #CREATE TOGGLE SWITCHES TO DISPLAY CORRECT DATA SETS ON GRAPH (this will be hard probably)
    #using imported images overlayed on buttons for simulation of a toggle switch

    #DEFINE TOGGLE IMAGES
    ON_IMU = ImageTk.PhotoImage(Image.open("images/ON.jpg"))
    OFF_IMU = ImageTk.PhotoImage(Image.open("images/OFF.jpg"))

    #DEFINE BUTTON STATE BOOLEANS
    global L_vertical_on
    global L_horizontal_on
    global L_Total_on

    global R_vertical_on
    global R_horizontal_on
    global R_Total_on

    L_vertical_on = False
    L_horizontal_on = False
    L_Total_on = False

    R_vertical_on = False
    R_horizontal_on = False
    R_Total_on = False

    #DEFINE CALLABLE FUNCTIONS
    #LEFT
    def L_vertical_SWITCH():
    
        global L_vertical_on
    
        if L_vertical_on == False:
            L_vertical_on = True
            L_vertical_button.config(image = ON_IMU)
            L_vertical_button['state'] = DISABLED
            #and now plot appropriate data set
            p6_graph_variable.plot(TIME_accel, left_vertical_acceleration_filtered, color = "red", linestyle = "dotted")
            p6_canvas.draw()
        else:
            L_vertical_button.config(image = OFF_IMU)
            L_vertical_on = False

    def L_horizontal_SWITCH():
    
        global L_horizontal_on
    
        if L_horizontal_on == False:
            L_horizontal_on = True
            L_horizontal_button.config(image = ON_IMU)
            L_horizontal_button['state'] = DISABLED
            
            p6_graph_variable.plot(TIME_accel, left_horizontal_acceleration_filtered, color = "red", linestyle = "dashed")
            p6_canvas.draw()
        else:
            L_horizontal_button.config(image = OFF_IMU)
            L_horizontal_on = False

    def L_Total_SWITCH():
    
        global L_Total_on
    
        if L_Total_on == False:
            L_Total_on = True
            L_Total_button.config(image = ON_IMU)
            L_Total_button['state'] = DISABLED
            
            p6_graph_variable.plot(TIME_accel, left_sum_acceleration_filtered, color = "red", linestyle = "solid")
            p6_canvas.draw()
        else:
            L_Total_button.config(image = OFF_IMU)
            L_Total_on = False

    #RIGHT
    def R_vertical_SWITCH():
    
        global R_vertical_on
    
        if R_vertical_on == False:
            R_vertical_on = True
            R_vertical_button.config(image = ON_IMU)
            R_vertical_button['state'] = DISABLED
            
            p6_graph_variable.plot(TIME_accel, right_vertical_acceleration_filtered, color = "blue", linestyle = "dotted")
            p6_canvas.draw()
        else:
            R_vertical_button.config(image = OFF_IMU)
            R_vertical_on = False

    def R_horizontal_SWITCH():
    
        global R_horizontal_on
    
        if R_horizontal_on == False:
            R_horizontal_on = True
            R_horizontal_button.config(image = ON_IMU)
            R_horizontal_button['state'] = DISABLED
            
            p6_graph_variable.plot(TIME_accel, right_horizontal_acceleration_filtered, color = "blue", linestyle = "dashed")
            p6_canvas.draw()
        else:
            R_horizontal_button.config(image = OFF_IMU)
            R_horizontal_on = False

    def R_Total_SWITCH():
    
        global R_Total_on
    
        if R_Total_on == False:
            R_Total_on = True
            R_Total_button.config(image = ON_IMU)
            R_Total_button['state'] = DISABLED
            
            p6_graph_variable.plot(TIME_accel, right_sum_acceleration_filtered, color = "blue", linestyle = "solid")
            p6_canvas.draw()
        else:
            R_Total_button.config(image = OFF_IMU)
            R_Total_on = False

    L_vertical_button = Button(page6, image = OFF_IMU, bd = 0, command = L_vertical_SWITCH)
    L_vertical_button.place(relx = 0.1, rely = 0.25, anchor = "center")

    L_horizontal_button = Button(page6, image = OFF_IMU, bd = 0, command = L_horizontal_SWITCH)
    L_horizontal_button.place(relx = 0.1, rely = 0.35, anchor = "center")

    L_Total_button = Button(page6, image = OFF_IMU, bd = 0, command = L_Total_SWITCH)
    L_Total_button.place(relx = 0.1, rely = 0.45, anchor = "center")

    R_vertical_button = Button(page6, image = OFF_IMU, bd = 0, command = R_vertical_SWITCH)
    R_vertical_button.place(relx = 0.9, rely = 0.25, anchor = "center")

    R_horizontal_button = Button(page6, image = OFF_IMU, bd = 0, command = R_horizontal_SWITCH)
    R_horizontal_button.place(relx = 0.9, rely = 0.35, anchor = "center")

    R_Total_button = Button(page6, image = OFF_IMU, bd = 0, command = R_Total_SWITCH)
    R_Total_button.place(relx = 0.9, rely = 0.45, anchor = "center")

    #CREATE LABELS
    L_vertical_label = Label(page6, text = "LEFT FOOT VERTICAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    L_vertical_label.place(relx = 0.1, rely = 0.2, anchor = "center")
    
    L_horizontal_label = Label(page6, text = "LEFT FOOT HORIZONTAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    L_horizontal_label.place(relx = 0.1, rely = 0.3, anchor = "center")
    
    L_Total_label = Label(page6, text = "LEFT FOOT TOTAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    L_Total_label.place(relx = 0.1, rely = 0.4, anchor = "center")
    
    R_vertical_label = Label(page6, text = "RIGHT FOOT VERTICAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    R_vertical_label.place(relx = 0.9, rely = 0.2, anchor = "center")
    
    R_horizontal_label = Label(page6, text = "RIGHT FOOT HORIZONTAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    R_horizontal_label.place(relx = 0.9, rely = 0.3, anchor = "center")
    
    R_Total_label = Label(page6, text = "RIGHT FOOT TOTAL ACCELERATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    R_Total_label.place(relx = 0.9, rely = 0.4, anchor = "center")

acceleration_plot_button = Button(page6, text = "DISPLAY IMU DATA", font = ('Helvetica', 13, 'bold'), bg = 'green2', fg = 'ghost white', command = unlockAcceleration)
acceleration_plot_button.place(relx = 0.5, rely = 0.05, anchor = "center")

#section for page3 help button
def p6HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page6_HELP = Button(page6, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p6HELP_FUNCTION)
page6_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)
#######################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 7

#section for page3 help button
def p7HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page7_HELP = Button(page7, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p7HELP_FUNCTION)
page7_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)

##OKAY IN HERE NEED TO COME UP WITH AN ALGORITH FOR IDENTIFYING HEEL ON AND TOE OFF FROM THE DATA, FROM THIS IT FOLLOWS THAT CALULATING THE PARAMETERS IS MORE OR LESS EASY AFAIK
#the question is can it be done easily just using the heel sensor and maybe the medial toe sensor or would it be better to calculate from the SUM FSR data

#current idea is to use individual data streams from FSR1 and FSR2, and use diff() function to peak find and back and forward search for troughs
#corresponding to the heel on and TOE off events

#first thing to do is to reduce array size to the desired time window 10-15 seconds. This should be done within a button function

def calculate_gait():
    
    #ENABLE GAIT CYCLE PLOTS BUTTON ON PAGE 8 as NOW THE PROPER ARRAYS EXIST FOR PLOTTING
    gait_cycle_plots_button['state'] = NORMAL
    
    #NEED TO DEFINE THE FSR INDEX's AS GLOBAL SO CAN BE ACCESSED BY THE GAIT CYCLE PLOTTING FUNCTION ON PAGE 8
    global LEFT_heel_on_array
    global LEFT_toe_off_array
    
    global RIGHT_heel_on_array
    global RIGHT_toe_off_array
    
    gait_parameters_button['state'] = DISABLED #so that they cant click it again and fuck everything up
    
    #try:
    #resize arrays to desired lengths for gait event capture (10-25)s

    #THIS IS THE FORMAT:
        #FSR 1 = MEDIAL TOE
        #FSR 2 = LATERAL TOE
        #FSR 3 = HEEL

    TIME1 = np.interp(timeVector, [0, 2999], [0, 30]) #NEW X AXIS ARRAY, can pull out specific range from here

    #now create index grab to pull specific range out of both the time data and the force data
    index = list(range(1000,2501,1)) #similar to linspace in MATLAB, this basically goes from 10 seconds to 25 seconds as discussed 

    TIME1_reduced = TIME1[index] #kinda unnceccesary but follows the logic so will leave in for now
    #now need to pull out the correct index range from the FSR data for both HEEL and TOE for both LEFt and RIGHT foot 
    #LEFT 
    LEFT_mTOE_FSR_REDUCED = LEFT_FSR1_NORMALIZED[index]
    LEFT_HEEL_FSR_REDUCED = LEFT_FSR3_NORMALIZED[index]

    #RIGHT
    RIGHT_mTOE_FSR_REDUCED = RIGHT_FSR1_NORMALIZED[index]
    RIGHT_HEEL_FSR_REDUCED = RIGHT_FSR3_NORMALIZED[index]

    #IMPORTANT STEP HERE, AMPLITUDE SCALE ALL DATA BETWEEN 0 and 1: this would probably solve the issue of different sensor sensitivities too (for plotting page 5 and also gait cycle plots)
    #first convert to numpy arrays
    TIME1_reduced = np.array(TIME1_reduced)

    LEFT_mTOE_FSR_REDUCED = np.array(LEFT_mTOE_FSR_REDUCED)
    LEFT_HEEL_FSR_REDUCED = np.array(LEFT_HEEL_FSR_REDUCED)

    RIGHT_mTOE_FSR_REDUCED = np.array(RIGHT_mTOE_FSR_REDUCED)
    RIGHT_HEEL_FSR_REDUCED = np.array(RIGHT_HEEL_FSR_REDUCED)

    ##NOW AMPLITUDE SCALE##
    LT_amplitudeScaler = np.amax(LEFT_mTOE_FSR_REDUCED)
    LH_amplitudeScaler = np.amax(LEFT_HEEL_FSR_REDUCED)

    RT_amplitudeScaler = np.amax(RIGHT_mTOE_FSR_REDUCED)
    RH_amplitudeScaler = np.amax(RIGHT_HEEL_FSR_REDUCED)
    #############################
    LT_SCALED_DATA = LEFT_mTOE_FSR_REDUCED/LT_amplitudeScaler
    LH_SCALED_DATA = LEFT_HEEL_FSR_REDUCED/LH_amplitudeScaler

    RT_SCALED_DATA = RIGHT_mTOE_FSR_REDUCED/RT_amplitudeScaler
    RH_SCALED_DATA = RIGHT_HEEL_FSR_REDUCED/RH_amplitudeScaler #NOW THIS DATA WILL BE USED IN THE FIND PEAKS FUNCTION
    #these scaled data sets may need to be converted to numpy arrays

    #now find the HEEL ON and TOE OFF events from these arrays
    #SOLVE FOR LEFT FOOT
    peaks_LEFT_mtoe = find_peaks(LT_SCALED_DATA, distance = 60, prominence = 0.2) #distance of 50 can be changed and experimented with, this equates to half a second of time since sample freq = 100hz
    peaks_LEFT_heel = find_peaks(LH_SCALED_DATA, distance = 60, prominence = 0.2)

    peaks_LEFT_mtoe = peaks_LEFT_mtoe[0] #pull out the zeroth index since find_peaks returns some weird dictionary or tuple or something
    peaks_LEFT_heel = peaks_LEFT_heel[0]

    LEFT_toe_off_array = []
    LEFT_heel_on_array = []

    #now define looping algorithms
    for LT in peaks_LEFT_mtoe: #THE IF STATEMENTS IN THIS ALGORITHM ARE ONE WAY OF DOING IT, but check the other 3 algos for the cleaner way
    
        LT_starting_point = LT

        LT_solved = False
        
        if LT_starting_point == len(LT_SCALED_DATA) or LT_starting_point <= 4: #since forward searching want to cancel search before max index of data set is exceeded
            LT_solved = True #since back searching by 5 samples, will still work if peak detected at 5th index position, but will skip if peak detected before 5
        
        while LT_solved == False:
            
            LT_test_sample_0 = LT_SCALED_DATA[LT_starting_point]
            LT_test_sample_1 = LT_SCALED_DATA[LT_starting_point - 1]
            LT_test_sample_2 = LT_SCALED_DATA[LT_starting_point - 2]
            LT_test_sample_3 = LT_SCALED_DATA[LT_starting_point - 3]
            LT_test_sample_4 = LT_SCALED_DATA[LT_starting_point - 4]
            LT_test_sample_5 = LT_SCALED_DATA[LT_starting_point - 5] #5 points behind starting point since forward searching through data for toe off
        
            if LT_test_sample_0 < LT_SCALED_DATA[LT]*0.8 and LT_test_sample_0 == LT_test_sample_1 and LT_test_sample_0 == LT_test_sample_2 and LT_test_sample_0 == LT_test_sample_3 and LT_test_sample_0 == LT_test_sample_4 and LT_test_sample_0 == LT_test_sample_5:
                LEFT_toe_off_array.append(LT_starting_point - 6)
                LT_solved = True

            else:
                LT_starting_point = LT_starting_point + 1
                
                if LT_starting_point == len(LT_SCALED_DATA) or LT_starting_point <= 4: #since forward searching want to cancel search before max index of data set is exceeded
                    LT_solved = True #since back searching by 5 samples, will still work if peak detected at 5th index position, but will skip if peak detected before 5


    for LH in peaks_LEFT_heel:

        LH_starting_point = LH

        LH_solved = False
        
        if LH_starting_point == -1 or LH_starting_point >= len(LH_SCALED_DATA) - 5: #negative 1 index because this will still allow for the 0th index to be tested
            LH_solved = True #this is basically a defense against the zeroth index (probably just an edge case)

        while LH_solved == False:
        
            LH_test_sample_0 = LH_SCALED_DATA[LH_starting_point]
            LH_test_sample_1 = LH_SCALED_DATA[LH_starting_point + 1]
            LH_test_sample_2 = LH_SCALED_DATA[LH_starting_point + 2]
            LH_test_sample_3 = LH_SCALED_DATA[LH_starting_point + 3]
            LH_test_sample_4 = LH_SCALED_DATA[LH_starting_point + 4]
            LH_test_sample_5 = LH_SCALED_DATA[LH_starting_point + 5] #needs to be + 5 since we are back searching in this case
            #now maybe try taking absolute value of difference between the two points
        
            if LH_test_sample_0 < LH_SCALED_DATA[LH]*0.8 and LH_test_sample_0 == LH_test_sample_1 and LH_test_sample_0 == LH_test_sample_2 and LH_test_sample_0 == LH_test_sample_3 and LH_test_sample_0 == LH_test_sample_4 and LH_test_sample_0 == LH_test_sample_5: #basically saying if the two point are the same which should only occur at the trough I think
                LEFT_heel_on_array.append(LH_starting_point + 6) #NOTICE THIS IS 1 HIGHER INDEX THAN TEST SAMPLE 1 AS THIS WILL BE FIRST POINT WHERE FORCE RISES UP
                LH_solved = True
            else:
                LH_starting_point = LH_starting_point - 1 #back search for heel on location
                
                if LH_starting_point == -1 or LH_starting_point >= len(LH_SCALED_DATA) - 5: #negative 1 index because this will still allow for the 0th index to be tested
                    LH_solved = True #this is basically a defense against the zeroth index (probably just an edge case)

    #SOLVE FOR RIGHT FOOT 
    peaks_RIGHT_mtoe = find_peaks(RT_SCALED_DATA, distance = 60, prominence = 0.2)
    peaks_RIGHT_heel = find_peaks(RH_SCALED_DATA, distance = 60, prominence = 0.2)

    peaks_RIGHT_mtoe = peaks_RIGHT_mtoe[0]
    peaks_RIGHT_heel = peaks_RIGHT_heel[0]

    RIGHT_toe_off_array = []
    RIGHT_heel_on_array = []

    #define right foot looping algorithms
    for RT in peaks_RIGHT_mtoe:
        RT_starting_point = RT
    
        RT_solved = False
        
        if RT_starting_point == len(RT_SCALED_DATA) or RT_starting_point <= 4: #since forward searching want to cancel search before max index of data set is exceeded
            RT_solved = True #since back searching by 5 samples, will still work if peak detected at 5th index position, but will skip if peak detected before 5
    
        #since looking for toe off, want to forward search from the peak
        while RT_solved == False:
            
            RT_test_sample_0 = RT_SCALED_DATA[RT_starting_point]
            RT_test_sample_1 = RT_SCALED_DATA[RT_starting_point - 1]
            RT_test_sample_2 = RT_SCALED_DATA[RT_starting_point - 2]
            RT_test_sample_3 = RT_SCALED_DATA[RT_starting_point - 3]
            RT_test_sample_4 = RT_SCALED_DATA[RT_starting_point - 4]
            RT_test_sample_5 = RT_SCALED_DATA[RT_starting_point - 5] #5 points behind starting point since forward searching through data for toe off
        
            if RT_test_sample_0 < RT_SCALED_DATA[RT]*0.8 and RT_test_sample_0 == RT_test_sample_1 and RT_test_sample_0 == RT_test_sample_2 and RT_test_sample_0 == RT_test_sample_3 and RT_test_sample_0 == RT_test_sample_4 and RT_test_sample_0 == RT_test_sample_5:
                RIGHT_toe_off_array.append(RT_starting_point - 6)
                RT_solved = True
            else:
                RT_starting_point = RT_starting_point + 1
                
                if RT_starting_point == len(RT_SCALED_DATA) or RT_starting_point <= 4: #since forward searching want to cancel search before max index of data set is exceeded
                    RT_solved = True #since back searching by 5 samples, will still work if peak detected at 5th index position, but will skip if peak detected before 5

    for RH in peaks_RIGHT_heel:
        RH_starting_point = RH
    
        RH_solved = False
        
        if RH_starting_point == -1 or RH_starting_point >= len(RH_SCALED_DATA) - 5: #negative 1 index because this will still allow for the 0th index to be tested
            RH_solved = True #this is basically a defense against the zeroth index (probably just an edge case)
    
        #since looking for heel on, want to back search from the peak
        while RH_solved == False:
        
            RH_test_sample_0 = RH_SCALED_DATA[RH_starting_point]
            RH_test_sample_1 = RH_SCALED_DATA[RH_starting_point + 1]
            RH_test_sample_2 = RH_SCALED_DATA[RH_starting_point + 2]
            RH_test_sample_3 = RH_SCALED_DATA[RH_starting_point + 3]
            RH_test_sample_4 = RH_SCALED_DATA[RH_starting_point + 4]
            RH_test_sample_5 = RH_SCALED_DATA[RH_starting_point + 5] #needs to be + 5 since we are back searching in this case
            #now maybe try taking absolute value of difference between the two points
        
            if RH_test_sample_0 < RH_SCALED_DATA[RH]*0.8 and RH_test_sample_0 == RH_test_sample_1 and RH_test_sample_0 == RH_test_sample_2 and RH_test_sample_0 == RH_test_sample_3 and RH_test_sample_0 == RH_test_sample_4 and RH_test_sample_0 == RH_test_sample_5: #basically saying if the two point are the same which should only occur at the trough I think
                RIGHT_heel_on_array.append(RH_starting_point + 6) #NOTICE THIS IS 1 HIGHER INDEX THAN TEST SAMPLE 1 AS THIS WILL BE FIRST POINT WHERE FORCE RISES UP
                RH_solved = True
            else:
                RH_starting_point = RH_starting_point - 1 #back search for heel on location
                
                if RH_starting_point == -1 or RH_starting_point >= len(RH_SCALED_DATA) - 5: #negative 1 index because this will still allow for the 0th index to be tested
                    RH_solved = True #this is basically a defense against the zeroth index (probably just an edge case)

    ####NOW HERE IS A LIST OF ALL THE ARRAY FULL OF THE IMPORTANT EVENT INDEX POSITIONS
    #LEFT LEG
    LEFT_heel_on_array = LEFT_heel_on_array #ARRAY CONTAINS ALL INDEX POSITIONS OF HEEL ON FOR LEFT FOOT
    LEFT_toe_off_array = LEFT_toe_off_array #AND THIS IS THE GOLDEN ARRAY FULL OF INDEX's OF TOE OFF POINTS FOR THE LEFT FOOT
    #RIGHT FOOT
    RIGHT_heel_on_array = RIGHT_heel_on_array #AND THIS ARRAY CONTAINS ALL INDEX POSITIONS FOR HEEL ON EVENTS FOR THE RIGHT FOOT 
    RIGHT_toe_off_array = RIGHT_toe_off_array
    
    ##IMPORTANT: HERE GOING TO DO DUPLICATE DELETION. In case mini peak is detected and forward and back search arrives at same trough, wan't to remove duplicates
    #this is important because if one has a duplicate, the array length will be longer than the other one and the last element will be removed 
    #this will then mess up the math for the parameter calculation
    
    #the data structure is currently a list 
    LEFT_heel_on_array = list(dict.fromkeys(LEFT_heel_on_array))
    LEFT_toe_off_array = list(dict.fromkeys(LEFT_toe_off_array))
    
    RIGHT_heel_on_array = list(dict.fromkeys(RIGHT_heel_on_array))
    RIGHT_toe_off_array = list(dict.fromkeys(RIGHT_toe_off_array)) #NOW ALL DUPLICATES SHOULD BE DELETED
    #do the duplicate deletion for the accelerometer as well

    #NOW WITH THESE ARRAYS SHOULD BE ABLE TO USE THE ELEMENTS TO CALCULATE THE TEMPORAL PARAMETERS
    #first need to pull out the TIME values from the time array
    LEFT_heel_on_TIMESTAMPS = TIME1_reduced[LEFT_heel_on_array]
    LEFT_toe_off_TIMESTAMPS = TIME1_reduced[LEFT_toe_off_array]

    RIGHT_heel_on_TIMESTAMPS = TIME1_reduced[RIGHT_heel_on_array]
    RIGHT_toe_off_TIMESTAMPS = TIME1_reduced[RIGHT_toe_off_array]
    
    #convert to numpy arrays
    LEFT_heel_on_TIMESTAMPS = np.array(LEFT_heel_on_TIMESTAMPS)
    LEFT_toe_off_TIMESTAMPS = np.array(LEFT_toe_off_TIMESTAMPS)
    
    RIGHT_heel_on_TIMESTAMPS = np.array(RIGHT_heel_on_TIMESTAMPS)
    RIGHT_toe_off_TIMESTAMPS = np.array(RIGHT_toe_off_TIMESTAMPS)
    
    #######FUCK YOU FIRST IMPORTANT THING TO DO IS TO RESIZE TO MAKE SURE ALL 4 ARRAYS ARE THE SAME LEGNTH - THIS IS SUPER IMPORTANT 
    LH_length = len(LEFT_heel_on_TIMESTAMPS)
    LT_length = len(LEFT_toe_off_TIMESTAMPS)
    
    RH_length = len(RIGHT_heel_on_TIMESTAMPS)
    RT_length = len(RIGHT_toe_off_TIMESTAMPS)
    
    FSR_array_lengths = [LH_length, LT_length, RH_length, RT_length]
    FSR_array_lengths_MINIMUM = min(FSR_array_lengths)
    
    #now do the resize
    LEFT_heel_on_TIMESTAMPS = LEFT_heel_on_TIMESTAMPS[0:FSR_array_lengths_MINIMUM]
    LEFT_toe_off_TIMESTAMPS = LEFT_toe_off_TIMESTAMPS[0:FSR_array_lengths_MINIMUM]
    RIGHT_heel_on_TIMESTAMPS = RIGHT_heel_on_TIMESTAMPS[0:FSR_array_lengths_MINIMUM]
    RIGHT_toe_off_TIMESTAMPS = RIGHT_toe_off_TIMESTAMPS[0:FSR_array_lengths_MINIMUM]
    
    #NOW FROM THESE CAN CALCULATE THE TEMPORAL PARAMETERS 

    #PARAMETERS TO CALCULATE
    #1. STANCE TIME - left and right
    #2. SWING TIME - left and right
    #3. CYCLE TIME - left and right
    #4. STEP TIME - left and right
    #5. SINGLE SUPPORT - left and right
    #6. CADENCE =  steps/min - just one needed
    #7. DOUBLE SUPPORT - left and right

    #START PARAMETER ALGORITHM HERE

    #LEFT FOOT MATH
    LEFT_check_heel_index = LEFT_heel_on_array[0]
    LEFT_check_toe_index = LEFT_toe_off_array[0]

    #now that arrays are same length, check index positions and employ developed algorithms accordingly 
    if LEFT_check_heel_index < LEFT_check_toe_index:
        #i.e. heel on comes first 
        LEFT_stance_phase_array = (LEFT_toe_off_TIMESTAMPS) - (LEFT_heel_on_TIMESTAMPS)
        stance_phase_left_std = np.std(LEFT_stance_phase_array)
        stance_phase_left = np.sum(LEFT_stance_phase_array)/len(LEFT_stance_phase_array) #spits out one average value for stance phase 

        #NOW SWING PHASE ALGORITHM
        LEFT_case1_iterator = 1 #because of offset in data, want to start at 1st element rather than 0th element

        LEFT_swing_phase_array = []

        while LEFT_case1_iterator <= len(LEFT_heel_on_TIMESTAMPS) - 1:

            left_swing_phase_value = LEFT_heel_on_TIMESTAMPS[LEFT_case1_iterator] - LEFT_toe_off_TIMESTAMPS[LEFT_case1_iterator - 1]
            LEFT_swing_phase_array.append(left_swing_phase_value)

            LEFT_case1_iterator = LEFT_case1_iterator + 1

        LEFT_swing_phase_array = np.array(LEFT_swing_phase_array)
        swing_phase_left_std = np.std(LEFT_swing_phase_array)
        swing_phase_left = np.sum(LEFT_swing_phase_array)/len(LEFT_swing_phase_array)

    else: #i.e. toe off happens first 

        LEFT_case2_iterator = 1

        LEFT_stance_phase_array = []

        while LEFT_case2_iterator <= len(LEFT_toe_off_TIMESTAMPS) - 1:

            left_stance_phase_value = LEFT_toe_off_TIMESTAMPS[LEFT_case2_iterator] - LEFT_heel_on_TIMESTAMPS[LEFT_case2_iterator - 1]
            LEFT_stance_phase_array.append(left_stance_phase_value)

            LEFT_case2_iterator = LEFT_case2_iterator + 1
    
        LEFT_stance_phase_array = np.array(LEFT_stance_phase_array)
        stance_phase_left_std = np.std(LEFT_stance_phase_array)
        stance_phase_left = np.sum(LEFT_stance_phase_array)/len(LEFT_stance_phase_array)

        #and swing phase
        LEFT_swing_phase_array = (LEFT_heel_on_TIMESTAMPS) - (LEFT_toe_off_TIMESTAMPS)
        swing_phase_left_std = np.std(LEFT_swing_phase_array)
        swing_phase_left = np.sum(LEFT_swing_phase_array)/len(LEFT_swing_phase_array)

    #RIGHT FOOT MATH
    RIGHT_check_heel_index = RIGHT_heel_on_array[0]
    RIGHT_check_toe_index = RIGHT_toe_off_array[0]

    #now that arrays are same length, check index positions and employ developed algorithms accordingly 
    if RIGHT_check_heel_index < RIGHT_check_toe_index:
        #i.e. heel on comes first 
        RIGHT_stance_phase_array = (RIGHT_toe_off_TIMESTAMPS) - (RIGHT_heel_on_TIMESTAMPS)
        stance_phase_right_std = np.std(RIGHT_stance_phase_array)
        stance_phase_right = np.sum(RIGHT_stance_phase_array)/len(RIGHT_stance_phase_array) #spits out one average value for stance phase 

        #NOW SWING PHASE ALGORITHM
        RIGHT_case1_iterator = 1 #because of offset in data, want to start at 1st element rather than 0th element

        RIGHT_swing_phase_array = []

        while RIGHT_case1_iterator <= len(RIGHT_heel_on_TIMESTAMPS) - 1:

            right_swing_phase_value = RIGHT_heel_on_TIMESTAMPS[RIGHT_case1_iterator] - RIGHT_toe_off_TIMESTAMPS[RIGHT_case1_iterator - 1]
            RIGHT_swing_phase_array.append(right_swing_phase_value)

            RIGHT_case1_iterator = RIGHT_case1_iterator + 1

        RIGHT_swing_phase_array = np.array(RIGHT_swing_phase_array)
        swing_phase_right_std = np.std(RIGHT_swing_phase_array)
        swing_phase_right = np.sum(RIGHT_swing_phase_array)/len(RIGHT_swing_phase_array)

    else: #i.e. toe off happens first 

        RIGHT_case2_iterator = 1

        RIGHT_stance_phase_array = []

        while RIGHT_case2_iterator <= len(RIGHT_toe_off_TIMESTAMPS) - 1:

            right_stance_phase_value = RIGHT_toe_off_TIMESTAMPS[RIGHT_case2_iterator] - RIGHT_heel_on_TIMESTAMPS[RIGHT_case2_iterator - 1]
            RIGHT_stance_phase_array.append(right_stance_phase_value)

            RIGHT_case2_iterator = RIGHT_case2_iterator + 1
    
        RIGHT_stance_phase_array = np.array(RIGHT_stance_phase_array)
        stance_phase_right_std = np.std(RIGHT_stance_phase_array)
        stance_phase_right = np.sum(RIGHT_stance_phase_array)/len(RIGHT_stance_phase_array)

        #and swing phase
        RIGHT_swing_phase_array = (RIGHT_heel_on_TIMESTAMPS) - (RIGHT_toe_off_TIMESTAMPS)
        swing_phase_right_std = np.std(RIGHT_swing_phase_array)
        swing_phase_right = np.sum(RIGHT_swing_phase_array)/len(RIGHT_swing_phase_array)

    #NOW DO GAIT CYCLE CALCULATIONS
    #first contact of one foot to first contact of same foot
    left_gait_cycle_iterator = 1
    left_gait_cycle_array = []

    while left_gait_cycle_iterator <= len(LEFT_heel_on_TIMESTAMPS) - 1:
        left_gait_cycle_value = LEFT_heel_on_TIMESTAMPS[left_gait_cycle_iterator] - LEFT_heel_on_TIMESTAMPS[left_gait_cycle_iterator - 1]
        left_gait_cycle_array.append(left_gait_cycle_value)

        left_gait_cycle_iterator = left_gait_cycle_iterator + 1

    left_gait_cycle_array = np.array(left_gait_cycle_array)
    left_gait_cycle_std = np.std(left_gait_cycle_array)
    left_gait_cycle = np.sum(left_gait_cycle_array)/len(left_gait_cycle_array)

    right_gait_cycle_iterator = 1
    right_gait_cycle_array = []

    while right_gait_cycle_iterator <= len(RIGHT_heel_on_TIMESTAMPS) - 1:
        right_gait_cycle_value = RIGHT_heel_on_TIMESTAMPS[right_gait_cycle_iterator] - RIGHT_heel_on_TIMESTAMPS[right_gait_cycle_iterator - 1]
        right_gait_cycle_array.append(right_gait_cycle_value)

        right_gait_cycle_iterator = right_gait_cycle_iterator + 1

    right_gait_cycle_array = np.array(right_gait_cycle_array)
    right_gait_cycle_std = np.std(right_gait_cycle_array)
    right_gait_cycle = np.sum(right_gait_cycle_array)/len(right_gait_cycle_array)

    #NOW CALCULATE STEP TIME (only need one for this as the parameter STEP TIME includes activity from both legs)
    #just in case, going to make sure array lengths are the same even though i think they will be for sure

    #now they are the same length for sure, can do the math 
    check_left_heel_on_position = LEFT_heel_on_array[0]
    check_right_heel_on_position = RIGHT_heel_on_array[0]

    if check_left_heel_on_position < check_right_heel_on_position:
        #i.e. left heel on occurs first 
        left_step_time_array = (RIGHT_heel_on_TIMESTAMPS) - (LEFT_heel_on_TIMESTAMPS)
        #now calculate right step time
        right_step_iterator = 1
        right_step_time_array = []
        
        while right_step_iterator <= len(LEFT_heel_on_TIMESTAMPS) - 1:
            right_step_time_value = LEFT_heel_on_TIMESTAMPS[right_step_iterator] - RIGHT_heel_on_TIMESTAMPS[right_step_iterator - 1]
            right_step_time_array.append(right_step_time_value)
            
            right_step_iterator = right_step_iterator + 1
    else: #i.e. right heel on occurs first 
        right_step_time_array = (LEFT_heel_on_TIMESTAMPS) - (RIGHT_heel_on_TIMESTAMPS)
        
        left_step_time_iterator = 1
        left_step_time_array = []
        
        while left_step_time_iterator <= len(RIGHT_heel_on_TIMESTAMPS) - 1:
            left_step_time_value = RIGHT_heel_on_TIMESTAMPS[left_step_time_iterator] - LEFT_heel_on_TIMESTAMPS[left_step_time_iterator - 1]
            left_step_time_array.append(left_step_time_value)
            
            left_step_time_iterator = left_step_time_iterator + 1
        

    left_step_time_array = np.array(left_step_time_array)
    left_step_time_std = np.std(left_step_time_array)
    left_step_time = np.sum(left_step_time_array)/len(left_step_time_array)
    
    right_step_time_array = np.array(right_step_time_array)
    right_step_time_std = np.std(right_step_time_array)
    right_step_time = np.sum(right_step_time_array)/len(right_step_time_array)

    #NOW CALCULATE CADENCE 
    #in form of cycles/min
    left_CADENCE_array = 60/left_gait_cycle_array
    left_CADENCE_std = np.std(left_CADENCE_array)
    left_CADENCE = np.sum(left_CADENCE_array)/len(left_CADENCE_array)
    
    right_CADENCE_array = 60/right_gait_cycle_array
    right_CADENCE_std = np.std(right_CADENCE_array)
    right_CADENCE = np.sum(right_CADENCE_array)/len(right_CADENCE_array)
    
    #NOW NEED TO CALCULATE SINGLE AND DOULBE SUPPORT TIMES
    #SINGLE SUPPORT
    #THIS IS EQUIVALENT TO THE SWING TIME OF THE OPPOSITE LEG 
    single_support_left = swing_phase_right
    single_support_left_std = swing_phase_right_std
    
    single_support_right = swing_phase_left
    single_support_right_std = swing_phase_left_std
    
    #NOW CALCULATE DOUBLE SUPPORT (ALL ARRAYS SHOULD BE EXACT SAME LENGTH AT THIS POINT (LHO, LTO, RHO, RTO))
    #last tricky one
    
    #START WITH LEFT LEG
    #the definition for left double support is right-toe-off samples - left heel on samples 
    left_check_rightTOE_index = RIGHT_toe_off_TIMESTAMPS[0]
    left_check_leftHEEL_index = LEFT_heel_on_TIMESTAMPS[0]
    
    if left_check_leftHEEL_index < left_check_rightTOE_index: #left heel on happens first
        
        left_double_support_array = RIGHT_toe_off_TIMESTAMPS - LEFT_heel_on_TIMESTAMPS
    else: #right toe off happens first
        left_double_iterator = 1
        
        left_double_support_array = []
        while left_double_iterator <= len(RIGHT_toe_off_TIMESTAMPS) - 1:
            
            left_double_support_value = RIGHT_toe_off_TIMESTAMPS[left_double_iterator] - LEFT_heel_on_TIMESTAMPS[left_double_iterator - 1]
            left_double_support_array.append(left_double_support_value)
            
            left_double_iterator = left_double_iterator + 1
            
    #NOW DO FOR RIGHT LEG
    #definition for right double support is left toe off samples - right heel on samples
    right_check_leftTOE_index = LEFT_toe_off_TIMESTAMPS[0]
    right_check_rightHEEL_index = RIGHT_heel_on_TIMESTAMPS[0]
    
    if right_check_rightHEEL_index < right_check_leftTOE_index: #right heel on happens first 
        
        right_double_support_array = LEFT_toe_off_TIMESTAMPS - RIGHT_heel_on_TIMESTAMPS
    else: #left toe off happens first 
        right_double_iterator = 1
        
        right_double_support_array = []
        while right_double_iterator <= len(LEFT_toe_off_TIMESTAMPS) - 1:
            
            right_double_support_value = LEFT_toe_off_TIMESTAMPS[right_double_iterator] - RIGHT_heel_on_TIMESTAMPS[right_double_iterator - 1]
            right_double_support_array.append(right_double_support_value)
            
            right_double_iterator = right_double_iterator + 1
            
    left_double_support_array = np.array(left_double_support_array)
    left_double_support_std = np.std(left_double_support_array)
    left_double_support = np.sum(left_double_support_array)/len(left_double_support_array)
    
    right_double_support_array = np.array(right_double_support_array)
    right_double_support_std = np.std(right_double_support_array)
    right_double_support = np.sum(right_double_support_array)/len(right_double_support_array)
    
    #NOW THAT DOUBLE SUPPORT IS CALCULATED, CALCULATE THE % OF GAIT CYCLES FROM EACH STUPID THING
    left_stance_percentage = (stance_phase_left/left_gait_cycle)*100
    right_stance_percentage = (stance_phase_right/right_gait_cycle)*100
    
    left_swing_percentage = (swing_phase_left/left_gait_cycle)*100
    right_swing_percentage = (swing_phase_right/right_gait_cycle)*100
    
    left_single_support_percentage = (single_support_left/left_gait_cycle)*100
    right_single_support_percentage = (single_support_right/right_gait_cycle)*100
    
    left_double_support_percentage = (left_double_support/left_gait_cycle)*100
    right_double_support_percentage = (right_double_support/left_gait_cycle)*100
    
    #ALSO CALCULATE SYMMETRY PARAMETERS: using ROBINSON index
    stance_phase_SYMMETRY = abs((2*(stance_phase_left - stance_phase_right)/(stance_phase_left + stance_phase_right))*100) #need absolute value because this is negative sometimes
    
    cycle_SYMMETRY = abs((2*(left_gait_cycle - right_gait_cycle)/(left_gait_cycle + right_gait_cycle))*100)


    #NOW ALL TEMPORAL PARAMETERS SHOULD BE CALCULATED
    #re-save all relevent params
    STANCE_PHASE_LEFT_TEMPORAL_FSR = stance_phase_left
    STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR = stance_phase_left_std
    STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE_FSR = left_stance_percentage

    STANCE_PHASE_RIGHT_TEMPORAL_FSR = stance_phase_right
    STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR = stance_phase_right_std
    STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE_FSR = right_stance_percentage

    SWING_PHASE_LEFT_TEMPORAL_FSR = swing_phase_left
    SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR = swing_phase_left_std
    SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE_FSR = left_swing_percentage

    SWING_PHASE_RIGHT_TEMPORAL_FSR = swing_phase_right
    SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR = swing_phase_right_std
    SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE_FSR = right_swing_percentage

    SINGLE_SUPPORT_LEFT_TEMPORAL_FSR = single_support_left
    SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR = single_support_left_std
    SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE_FSR = left_single_support_percentage

    SINGLE_SUPPORT_RIGHT_TEMPORAL_FSR = single_support_right
    SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR = single_support_right_std
    SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE_FSR = right_single_support_percentage

    GAIT_CYCLE_LEFT_TEMPORAL_FSR = left_gait_cycle
    GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR = left_gait_cycle_std
    
    GAIT_CYCLE_RIGHT_TEMPORAL_FSR = right_gait_cycle
    GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR = right_gait_cycle_std

    LEFT_STEP_TIME_TEMPORAL_FSR = left_step_time
    LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR = left_step_time_std
    
    RIGHT_STEP_TIME_TEMPORAL_FSR = right_step_time
    RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR = right_step_time_std
    
    LEFT_CADENCE_TEMPORAL_FSR = left_CADENCE
    LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR = left_CADENCE_std
    
    RIGHT_CADENCE_TEMPORAL_FSR = right_CADENCE
    RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR = right_CADENCE_std
    
    LEFT_DOUBLE_SUPPORT_TEMPORAL_FSR = left_double_support
    LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR = left_double_support_std
    LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_FSR = left_double_support_percentage
    
    RIGHT_DOUBLE_SUPPORT_TEMPORAL_FSR = right_double_support
    RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR = right_double_support_std
    RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_FSR = right_double_support_percentage
    
    STANCE_PHASE_SYMMETRY_FSR = stance_phase_SYMMETRY

    CYCLE_SYMMETRY_FSR = cycle_SYMMETRY
   
    ##IMU PARAMETER CALCULATION SECTION##########################################!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$$$$$$$$$$$$$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    
    def IMU_Calculations(): #NEED TO MAKE SURE PCB'S ARE ALIGNED W +X FACING UP AND -Y FACING FORWARD (based on the IMU coordinate system definition)
        
        global STANCE_PHASE_LEFT_TEMPORAL_IMU
        global STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU
        global STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE_IMU
        global STANCE_PHASE_RIGHT_TEMPORAL_IMU
        global STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU
        global STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE_IMU
        global SWING_PHASE_LEFT_TEMPORAL_IMU
        global SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU
        global SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE_IMU
        global SWING_PHASE_RIGHT_TEMPORAL_IMU
        global SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU
        global SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE_IMU
        global SINGLE_SUPPORT_LEFT_TEMPORAL_IMU
        global SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU
        global SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE_IMU
        global SINGLE_SUPPORT_RIGHT_TEMPORAL_IMU
        global SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU
        global SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE_IMU
        global GAIT_CYCLE_LEFT_TEMPORAL_IMU
        global GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU
        global GAIT_CYCLE_RIGHT_TEMPORAL_IMU
        global GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU
        global LEFT_STEP_TIME_TEMPORAL_IMU
        global LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU
        global RIGHT_STEP_TIME_TEMPORAL_IMU
        global RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU
        global LEFT_CADENCE_TEMPORAL_IMU
        global LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU
        global RIGHT_CADENCE_TEMPORAL_IMU
        global RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU
        global LEFT_DOUBLE_SUPPORT_TEMPORAL_IMU
        global LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU
        global LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_IMU
        global RIGHT_DOUBLE_SUPPORT_TEMPORAL_IMU
        global RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU
        global RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_IMU
        global STANCE_PHASE_SYMMETRY_IMU
        global CYCLE_SYMMETRY_IMU
        
        global LEFT_YAcceleration_NORMALIZED
        global LEFT_XAcceleration_NORMALIZED
        global RIGHT_YAcceleration_NORMALIZED
        global RIGHT_XAcceleration_NORMALIZED
        
        #START WITH LEFT LEG
        LEFT_YAcceleration_NORMALIZED  #FORWARD DIRECTION (already divided by gravity)
        LEFT_XAcceleration_NORMALIZED  #THESE ARE RAW UNFILTERED NOISY DATA OUT OF PCB - this is vertical direction
    
        TIME_accelerometer_reduced = TIME1[index] #breaks it down to 10-25 second range for sample
    
        #DESIGN THE PRE-DECIDED DIGITAL FILTER TO BE USED
        order = 2 #decided upon order of the butterworth filter
        sample_frequency = 100 #COMES FROM THE SENSOR SAMPLE RATE WHICH IS 100Hz
        nyquist_frequency = sample_frequency/2
        cutoff_frequency = 3.5 #this in in HZ and was decided upon based on the results of the FFT (check the appropriate MATLAB script)
    
        Ws = cutoff_frequency/nyquist_frequency
    
        b, a = signal.butter(order, Ws, btype = 'low') #LOW PASS FILTER
        #NOW THESE PARAMETERS WILL BE PASSED INTO THE FILTER FUNCTION TO FILTER THE ACCELERATION DATA
    
        LEFT_YAcceleration_reduced = LEFT_YAcceleration_NORMALIZED[index] #THIS CLIPS THE WINDOW TO THE 10-25 second range during the walk test
        #now this is noisy accelerometer data. since FFT has already been pre-done in MATLAB along with digital filter design, can directly implement chosen filter in here
        LEFT_XAcceleration_reduced = LEFT_XAcceleration_NORMALIZED[index]
        #NOW FILTER BOTH BEFORE ADDING THEM
        
        LEFT_YAcceleration_reduced_FILTERED = signal.filtfilt(b, a, LEFT_YAcceleration_reduced)
        LEFT_XAcceleration_reduced_FILTERED = signal.filtfilt(b, a, LEFT_XAcceleration_reduced)
        #now add the data together to get the same looking signal from the excel file
        #first convert to numpy array to be sure 
        LEFT_YAcceleration_reduced_FILTERED = np.array(LEFT_YAcceleration_reduced_FILTERED)
        LEFT_XAcceleration_reduced_FILTERED = np.array(LEFT_XAcceleration_reduced_FILTERED)
        
        #AMPLITUDE SCALE DATA BETWEEN 0 and 1 for prominence picking purporses
        #since going to just use x (vertical acceleration) for heel on toe off picking, just amplitude scale this one for now 
        Left_X_Amplitude_Scaler = np.amax(LEFT_XAcceleration_reduced_FILTERED)
        
        LEFT_XAcceleration_reduced_FILTERED_amplitudeScaled = LEFT_XAcceleration_reduced_FILTERED/Left_X_Amplitude_Scaler
        
        LEFT_ACCELERATION_SUM_filtered = LEFT_YAcceleration_reduced_FILTERED + LEFT_XAcceleration_reduced_FILTERED #now this signal can be used for peak detection
        #now amplitude scale Acceleration SUM
        left_sum_amplitude_scaler = np.amax(LEFT_ACCELERATION_SUM_filtered)
        
        LEFT_ACCELERATION_SUM_filtered_AmplitudeScaled = LEFT_ACCELERATION_SUM_filtered/left_sum_amplitude_scaler
        
        #now implement find peaks function
        #LEFT_ACCELERATION_SUM_peaks = find_peaks(LEFT_ACCELERATION_SUM_filtered, prominence = 0.1, distance = 25) #the prom and dist values seem to work relatively well? idk, will never get it perfect 
        #LEFT_ACCELERATION_SUM_peaks = LEFT_ACCELERATION_SUM_peaks[0]
        
        #NOW ACTUALLY ARE GOING TO FIND THE PEAKS FROM THE VERTICAL (X) ACCELERATION DATA AS THIS SEEMS TO BE A MORE ACCURATE WAY TO CALCULATE THE PARAMETERS
        LEFT_ACCELERATION_VERTICAL_peaks = find_peaks(LEFT_ACCELERATION_SUM_filtered_AmplitudeScaled, distance = 25, prominence = 0.1) #prom of 0.1 seems to be good but can be tweaked
        LEFT_ACCELERATION_VERTICAL_peaks = LEFT_ACCELERATION_VERTICAL_peaks[0]
        
        even_left_vertical_peaks_INDEX = LEFT_ACCELERATION_VERTICAL_peaks[0::2]
        odd_left_vertical_peaks_INDEX = LEFT_ACCELERATION_VERTICAL_peaks[1::2]
        
        #now with odd and even can take average and see what is higher to determine heel on and toe off (hopefully this method holds true)
        even_left_vertical_peaks_VALUES = LEFT_XAcceleration_reduced_FILTERED_amplitudeScaled[even_left_vertical_peaks_INDEX]
        odd_left_vertical_peaks_VALUES = LEFT_XAcceleration_reduced_FILTERED_amplitudeScaled[odd_left_vertical_peaks_INDEX]
        
        even_left_vertical_peaks_AVERAGE = np.sum(even_left_vertical_peaks_VALUES)/len(even_left_vertical_peaks_VALUES)
        odd_left_vertical_peaks_AVERAGE = np.sum(odd_left_vertical_peaks_VALUES)/len(odd_left_vertical_peaks_VALUES)
        
        if even_left_vertical_peaks_AVERAGE > odd_left_vertical_peaks_AVERAGE:
            #from data collected, it seems that ALMOST ALWAYS heel contact accelerations are higher than TOE OFF on average
            #this is the asumption we will use going forward 
            LEFT_heel_on_IMU = even_left_vertical_peaks_INDEX
            LEFT_toe_off_IMU = odd_left_vertical_peaks_INDEX
        else: #implying the odd values average is higher than the even 
            LEFT_heel_on_IMU = odd_left_vertical_peaks_INDEX
            LEFT_toe_off_IMU = even_left_vertical_peaks_INDEX
            
        #NOW RIGHT LEG
        RIGHT_YAcceleration_NORMALIZED
        RIGHT_XAcceleration_NORMALIZED
        
        #filter is already designed above, can be applied directly
        RIGHT_YAcceleration_reduced = RIGHT_YAcceleration_NORMALIZED[index]
        RIGHT_XAcceleration_reduced = RIGHT_XAcceleration_NORMALIZED[index]
        
        RIGHT_YAcceleration_reduced_FILTERED = signal.filtfilt(b, a, RIGHT_YAcceleration_reduced)
        RIGHT_XAcceleration_reduced_FILTERED = signal.filtfilt(b, a, RIGHT_XAcceleration_reduced)
        
        RIGHT_YAcceleration_reduced_FILTERED = np.array(RIGHT_YAcceleration_reduced_FILTERED)
        RIGHT_XAcceleration_reduced_FILTERED = np.array(RIGHT_XAcceleration_reduced_FILTERED)
        
        Right_X_Amplitude_Scaler = np.amax(RIGHT_XAcceleration_reduced_FILTERED)
        
        RIGHT_XAcceleration_reduced_FILTERED_amplitudeScaled = RIGHT_XAcceleration_reduced_FILTERED/Right_X_Amplitude_Scaler
        
        
        RIGHT_ACCELERATION_SUM_FILTERED = RIGHT_YAcceleration_reduced_FILTERED + RIGHT_XAcceleration_reduced_FILTERED
        
        right_sum_amplitude_scaler = np.amax(RIGHT_ACCELERATION_SUM_FILTERED)
        
        RIGHT_ACCELERATION_SUM_filtered_AmplitudeScaled = RIGHT_ACCELERATION_SUM_FILTERED/right_sum_amplitude_scaler
        
        #RIGHT_ACCELERATION_SUM_peaks = find_peaks(RIGHT_ACCELERATION_SUM_FILTERED, prominence = 0.1, distance = 25)
        #RIGHT_ACCELERATION_SUM_peaks = RIGHT_ACCELERATION_SUM_peaks[0]
        #NOW ACTUALLY ARE GOING TO FIND THE PEAKS FROM THE VERTICAL (X) ACCELERATION DATA AS THIS SEEMS TO BE A MORE ACCURATE WAY TO CALCULATE THE PARAMETERS
        RIGHT_ACCELERATION_VERTICAL_peaks = find_peaks(RIGHT_ACCELERATION_SUM_filtered_AmplitudeScaled, distance = 25, prominence = 0.1) #prom of 0.1 seems to be good but can be tweaked
        RIGHT_ACCELERATION_VERTICAL_peaks = RIGHT_ACCELERATION_VERTICAL_peaks[0]
        
        even_right_vertical_peaks_INDEX = RIGHT_ACCELERATION_VERTICAL_peaks[0::2]
        odd_right_vertical_peaks_INDEX = RIGHT_ACCELERATION_VERTICAL_peaks[1::2]
        
        #now with odd and even can take average and see what is higher to determine heel on and toe off (hopefully this method holds true)
        even_right_vertical_peaks_VALUES = RIGHT_XAcceleration_reduced_FILTERED_amplitudeScaled[even_right_vertical_peaks_INDEX]
        odd_right_vertical_peaks_VALUES = RIGHT_XAcceleration_reduced_FILTERED_amplitudeScaled[odd_right_vertical_peaks_INDEX]
        
        even_right_vertical_peaks_AVERAGE = np.sum(even_right_vertical_peaks_VALUES)/len(even_right_vertical_peaks_VALUES)
        odd_right_vertical_peaks_AVERAGE = np.sum(odd_right_vertical_peaks_VALUES)/len(odd_right_vertical_peaks_VALUES)
        
        if even_right_vertical_peaks_AVERAGE > odd_right_vertical_peaks_AVERAGE:
            #from data collected, it seems that ALMOST ALWAYS heel contact accelerations are higher than TOE OFF on average
            #this is the asumption we will use going forward 
            RIGHT_heel_on_IMU = even_left_vertical_peaks_INDEX
            RIGHT_toe_off_IMU = odd_left_vertical_peaks_INDEX
        else: #implying the odd values average is higher than the even 
            RIGHT_heel_on_IMU = odd_left_vertical_peaks_INDEX
            RIGHT_toe_off_IMU = even_left_vertical_peaks_INDEX
        
            
        #NOW THAT have heel on toe off index's for left and right foot, can pull out timestamps and use those for calculation of temporal parameters
        TIME_accelerometer_reduced = np.array(TIME_accelerometer_reduced)
        
        #convert to lists for indexing purposes (to avoid the previous stupid error)
        LEFT_heel_on_IMU = list(LEFT_heel_on_IMU)
        LEFT_toe_off_IMU = list(LEFT_toe_off_IMU)
        
        RIGHT_heel_on_IMU = list(RIGHT_heel_on_IMU)
        RIGHT_toe_off_IMU = list(RIGHT_toe_off_IMU)
        
        #DUPLICATE DELETION JUST IN CASE
        LEFT_heel_on_IMU = list(dict.fromkeys(LEFT_heel_on_IMU))
        LEFT_toe_off_IMU = list(dict.fromkeys(LEFT_toe_off_IMU))
    
        RIGHT_heel_on_IMU = list(dict.fromkeys(RIGHT_heel_on_IMU))
        RIGHT_toe_off_IMU = list(dict.fromkeys(RIGHT_toe_off_IMU))
        
        #####SUPER IMPORTANT STEP HERE###########
        #THIS COMES FROM test accelerometer data xlsx file#
        #TOE OFF AGREES PERFECTLY W FSR, BUT HEEL ON DOES NOT#
        #SEEMS TO BE OFFSET AND THE IMU DETECTED HS IS ACTUALLY SLIGHTLY BEFORE FSR#
        #CHOOSING TO TRUST TIME ACCURACY OF FSR SENSORS#
        #FROM DATA, ADDING ABOUT 15 SAMPLES TO EACH IMU HS INDEX WILL INCREASE THE ACCURACY SUBSTANTIALLY#
        #THIS IS A BIT SKETCHY, BUT NEEDS TO BE DONE#
        
        ##SO ADD 15 SAMPLES TO HS INDEX VALUES FOR BOTH RIGHT AND LEFT SIDE##
        #first need to convert to numpy array to add 15 to each sample
        LEFT_heel_on_IMU = np.array(LEFT_heel_on_IMU)
        LEFT_heel_on_IMU = LEFT_heel_on_IMU + 15 #this can be changed to whatever 
        
        RIGHT_heel_on_IMU = np.array(RIGHT_heel_on_IMU)
        RIGHT_heel_on_IMU = RIGHT_heel_on_IMU + 15 #IMPORTANT: THIS CAN PRODUCE AN INDEX ERROR OBVIOUSLY, NEED TO FIND A WAY TO FIX THIS
        
        #need to build in check to make sure max index is not exceeded
        LH_index_delete = np.where(LEFT_heel_on_IMU > 1500)
        LH_index_delete = LH_index_delete[0]
        LEFT_heel_on_IMU = np.delete(LEFT_heel_on_IMU, LH_index_delete)
        
        RH_index_delete = np.where(RIGHT_heel_on_IMU > 1500)
        RH_index_delete = RH_index_delete[0]
        RIGHT_heel_on_IMU = np.delete(RIGHT_heel_on_IMU, RH_index_delete) #NOW ALL CASES WHERE INDEX IS EXCEEDED SHOULD BE DELETED BEFORE INDEXING TIMESTAMPS
        
        #now convert back to list for indexing - bleh
        LEFT_heel_on_IMU = list(LEFT_heel_on_IMU)
        RIGHT_heel_on_IMU = list(RIGHT_heel_on_IMU)
    
        
        #now pull out timestamps for all event occurences
        LEFT_heel_on_IMU_TIMESTAMPS = TIME_accelerometer_reduced[LEFT_heel_on_IMU]
        LEFT_toe_off_IMU_TIMESTAMPS = TIME_accelerometer_reduced[LEFT_toe_off_IMU]
        
        RIGHT_heel_on_IMU_TIMESTAMPS = TIME_accelerometer_reduced[RIGHT_heel_on_IMU]
        RIGHT_toe_off_IMU_TIMESTAMPS = TIME_accelerometer_reduced[RIGHT_toe_off_IMU]
        
        #AGAIN HERE RESIZE TO MAKE SURE ALL 4 ARE SAME LENGTH
        LEFT_heel_on_IMU_TIMESTAMPS = np.array(LEFT_heel_on_IMU_TIMESTAMPS)
        LEFT_toe_off_IMU_TIMESTAMPS = np.array(LEFT_toe_off_IMU_TIMESTAMPS)
    
        RIGHT_heel_on_IMU_TIMESTAMPS = np.array(RIGHT_heel_on_IMU_TIMESTAMPS)
        RIGHT_toe_off_IMU_TIMESTAMPS = np.array(RIGHT_toe_off_IMU_TIMESTAMPS)
    
        #######FUCK YOU FIRST IMPORTANT THING TO DO IS TO RESIZE TO MAKE SURE ALL 4 ARRAYS ARE THE SAME LEGNTH - THIS IS SUPER IMPORTANT 
        LH_length_IMU = len(LEFT_heel_on_IMU_TIMESTAMPS)
        LT_length_IMU = len(LEFT_toe_off_IMU_TIMESTAMPS)
    
        RH_length_IMU = len(RIGHT_heel_on_IMU_TIMESTAMPS)
        RT_length_IMU = len(RIGHT_toe_off_IMU_TIMESTAMPS)
    
        IMU_array_lengths = [LH_length_IMU, LT_length_IMU, RH_length_IMU, RT_length_IMU]
        IMU_array_lengths_MINIMUM = min(IMU_array_lengths)
    
        #now do the resize
        LEFT_heel_on_IMU_TIMESTAMPS = LEFT_heel_on_IMU_TIMESTAMPS[0:IMU_array_lengths_MINIMUM]
        LEFT_toe_off_IMU_TIMESTAMPS = LEFT_toe_off_IMU_TIMESTAMPS[0:IMU_array_lengths_MINIMUM]
        RIGHT_heel_on_IMU_TIMESTAMPS = RIGHT_heel_on_IMU_TIMESTAMPS[0:IMU_array_lengths_MINIMUM]
        RIGHT_toe_off_IMU_TIMESTAMPS = RIGHT_toe_off_IMU_TIMESTAMPS[0:IMU_array_lengths_MINIMUM]
        
        #NOW ALL TEMPORAL PARAMETERS CAN BE CALCULATED FROM IMU DATA
        #should have just made a temporal params calculation function - fuck
        
        #START PARAMETER ALGORITHM HERE

        #LEFT FOOT MATH
        LEFT_check_heel_index_IMU = LEFT_heel_on_IMU[0]
        LEFT_check_toe_index_IMU = LEFT_toe_off_IMU[0]


        #now that arrays are same length, check index positions and employ developed algorithms accordingly 
        if LEFT_check_heel_index_IMU < LEFT_check_toe_index_IMU:
            #i.e. heel on comes first 
            LEFT_stance_phase_array_IMU = (LEFT_toe_off_IMU_TIMESTAMPS) - (LEFT_heel_on_IMU_TIMESTAMPS)
            stance_phase_left_std_IMU = np.std(LEFT_stance_phase_array_IMU)
            stance_phase_left_IMU = np.sum(LEFT_stance_phase_array_IMU)/len(LEFT_stance_phase_array_IMU) #spits out one average value for stance phase 

            #NOW SWING PHASE ALGORITHM
            LEFT_case1_iterator_IMU = 1 #because of offset in data, want to start at 1st element rather than 0th element

            LEFT_swing_phase_array_IMU = []

            while LEFT_case1_iterator_IMU <= len(LEFT_heel_on_IMU_TIMESTAMPS) - 1:

                left_swing_phase_value_IMU = LEFT_heel_on_IMU_TIMESTAMPS[LEFT_case1_iterator_IMU] - LEFT_toe_off_IMU_TIMESTAMPS[LEFT_case1_iterator_IMU - 1]
                LEFT_swing_phase_array_IMU.append(left_swing_phase_value_IMU)

                LEFT_case1_iterator_IMU = LEFT_case1_iterator_IMU + 1

            LEFT_swing_phase_array_IMU = np.array(LEFT_swing_phase_array_IMU)
            swing_phase_left_std_IMU = np.std(LEFT_swing_phase_array_IMU)
            swing_phase_left_IMU = np.sum(LEFT_swing_phase_array_IMU)/len(LEFT_swing_phase_array_IMU)

        else: #i.e. toe off happens first 

            LEFT_case2_iterator_IMU = 1

            LEFT_stance_phase_array_IMU = []

            while LEFT_case2_iterator_IMU <= len(LEFT_toe_off_IMU_TIMESTAMPS) - 1:

                left_stance_phase_value_IMU = LEFT_toe_off_IMU_TIMESTAMPS[LEFT_case2_iterator_IMU] - LEFT_heel_on_IMU_TIMESTAMPS[LEFT_case2_iterator_IMU - 1]
                LEFT_stance_phase_array_IMU.append(left_stance_phase_value_IMU)

                LEFT_case2_iterator_IMU = LEFT_case2_iterator_IMU + 1
    
            LEFT_stance_phase_array_IMU = np.array(LEFT_stance_phase_array_IMU)
            stance_phase_left_std_IMU = np.std(LEFT_stance_phase_array_IMU)
            stance_phase_left_IMU = np.sum(LEFT_stance_phase_array_IMU)/len(LEFT_stance_phase_array_IMU)

            #and swing phase
            LEFT_swing_phase_array_IMU = (LEFT_heel_on_IMU_TIMESTAMPS) - (LEFT_toe_off_IMU_TIMESTAMPS)
            swing_phase_left_std_IMU = np.std(LEFT_swing_phase_array_IMU)
            swing_phase_left_IMU = np.sum(LEFT_swing_phase_array_IMU)/len(LEFT_swing_phase_array_IMU)

        #RIGHT FOOT MATH
        RIGHT_check_heel_index_IMU = RIGHT_heel_on_IMU[0]
        RIGHT_check_toe_index_IMU = RIGHT_toe_off_IMU[0]


        #now that arrays are same length, check index positions and employ developed algorithms accordingly 
        if RIGHT_check_heel_index_IMU < RIGHT_check_toe_index_IMU:
            #i.e. heel on comes first 
            RIGHT_stance_phase_array_IMU = (RIGHT_toe_off_IMU_TIMESTAMPS) - (RIGHT_heel_on_IMU_TIMESTAMPS)
            stance_phase_right_std_IMU = np.std(RIGHT_stance_phase_array_IMU)
            stance_phase_right_IMU = np.sum(RIGHT_stance_phase_array_IMU)/len(RIGHT_stance_phase_array_IMU) #spits out one average value for stance phase 

            #NOW SWING PHASE ALGORITHM
            RIGHT_case1_iterator_IMU = 1 #because of offset in data, want to start at 1st element rather than 0th element

            RIGHT_swing_phase_array_IMU = []

            while RIGHT_case1_iterator_IMU <= len(RIGHT_heel_on_IMU_TIMESTAMPS) - 1:

                right_swing_phase_value_IMU = RIGHT_heel_on_IMU_TIMESTAMPS[RIGHT_case1_iterator_IMU] - RIGHT_toe_off_IMU_TIMESTAMPS[RIGHT_case1_iterator_IMU - 1]
                RIGHT_swing_phase_array_IMU.append(right_swing_phase_value_IMU)

                RIGHT_case1_iterator_IMU = RIGHT_case1_iterator_IMU + 1

            RIGHT_swing_phase_array_IMU = np.array(RIGHT_swing_phase_array_IMU)
            swing_phase_right_std_IMU = np.std(RIGHT_swing_phase_array_IMU)
            swing_phase_right_IMU = np.sum(RIGHT_swing_phase_array_IMU)/len(RIGHT_swing_phase_array_IMU)

        else: #i.e. toe off happens first 

            RIGHT_case2_iterator_IMU = 1

            RIGHT_stance_phase_array_IMU = []

            while RIGHT_case2_iterator_IMU <= len(RIGHT_toe_off_IMU_TIMESTAMPS) - 1:

                right_stance_phase_value_IMU = RIGHT_toe_off_IMU_TIMESTAMPS[RIGHT_case2_iterator_IMU] - RIGHT_heel_on_IMU_TIMESTAMPS[RIGHT_case2_iterator_IMU - 1]
                RIGHT_stance_phase_array_IMU.append(right_stance_phase_value_IMU)

                RIGHT_case2_iterator_IMU = RIGHT_case2_iterator_IMU + 1
    
            RIGHT_stance_phase_array_IMU = np.array(RIGHT_stance_phase_array_IMU)
            stance_phase_right_std_IMU = np.std(RIGHT_stance_phase_array_IMU)
            stance_phase_right_IMU = np.sum(RIGHT_stance_phase_array_IMU)/len(RIGHT_stance_phase_array_IMU)

            #and swing phase
            RIGHT_swing_phase_array_IMU = (RIGHT_heel_on_IMU_TIMESTAMPS) - (RIGHT_toe_off_IMU_TIMESTAMPS)
            swing_phase_right_std_IMU = np.std(RIGHT_swing_phase_array_IMU)
            swing_phase_right_IMU = np.sum(RIGHT_swing_phase_array_IMU)/len(RIGHT_swing_phase_array_IMU)

        #NOW STANCE AND SWING PHASE ARE DONE FOR BOTH LEGS, CAN DO OTHER TEMPORAL PARAMS
        single_support_left_IMU = swing_phase_right_IMU
        single_support_left_std_IMU = swing_phase_right_std_IMU

        single_support_right_IMU = swing_phase_left_IMU
        single_support_right_std_IMU = swing_phase_left_std_IMU

        #NOW DO GAIT CYCLE CALCULATIONS
        #first contact of one foot to first contact of same foot
        left_gait_cycle_iterator_IMU = 1
        left_gait_cycle_array_IMU = []

        while left_gait_cycle_iterator_IMU <= len(LEFT_heel_on_IMU_TIMESTAMPS) - 1:
            left_gait_cycle_value_IMU = LEFT_heel_on_IMU_TIMESTAMPS[left_gait_cycle_iterator_IMU] - LEFT_heel_on_IMU_TIMESTAMPS[left_gait_cycle_iterator_IMU - 1]
            left_gait_cycle_array_IMU.append(left_gait_cycle_value_IMU)

            left_gait_cycle_iterator_IMU = left_gait_cycle_iterator_IMU + 1

        left_gait_cycle_array_IMU = np.array(left_gait_cycle_array_IMU)
        left_gait_cycle_std_IMU = np.std(left_gait_cycle_array_IMU)
        left_gait_cycle_IMU = np.sum(left_gait_cycle_array_IMU)/len(left_gait_cycle_array_IMU)

        right_gait_cycle_iterator_IMU = 1
        right_gait_cycle_array_IMU = []

        while right_gait_cycle_iterator_IMU <= len(RIGHT_heel_on_IMU_TIMESTAMPS) - 1:
            right_gait_cycle_value_IMU = RIGHT_heel_on_IMU_TIMESTAMPS[right_gait_cycle_iterator_IMU] - RIGHT_heel_on_IMU_TIMESTAMPS[right_gait_cycle_iterator_IMU - 1]
            right_gait_cycle_array_IMU.append(right_gait_cycle_value_IMU)

            right_gait_cycle_iterator_IMU = right_gait_cycle_iterator_IMU + 1

        right_gait_cycle_array_IMU = np.array(right_gait_cycle_array_IMU)
        right_gait_cycle_std_IMU = np.std(right_gait_cycle_array_IMU)
        right_gait_cycle_IMU = np.sum(right_gait_cycle_array_IMU)/len(right_gait_cycle_array_IMU)

        #NOW CALCULATE STEP TIME (only need one for this as the parameter STEP TIME includes activity from both legs)
        #just in case, going to make sure array lengths are the same even though i think they will be for sure

        #now they are the same length for sure, can do the math 
        check_left_heel_on_position_IMU = LEFT_heel_on_IMU[0]
        check_right_heel_on_position_IMU = RIGHT_heel_on_IMU[0]

        if check_left_heel_on_position_IMU < check_right_heel_on_position_IMU:
            #i.e. left heel on occurs first 
            left_step_time_IMU_array = (RIGHT_heel_on_IMU_TIMESTAMPS) - (LEFT_heel_on_IMU_TIMESTAMPS)
            #now calculate right step time
            right_step_iterator_IMU = 1
            right_step_time_IMU_array = []
        
            while right_step_iterator_IMU <= len(LEFT_heel_on_IMU_TIMESTAMPS) - 1:
                right_step_time_IMU_value = LEFT_heel_on_IMU_TIMESTAMPS[right_step_iterator_IMU] - RIGHT_heel_on_IMU_TIMESTAMPS[right_step_iterator_IMU - 1]
                right_step_time_IMU_array.append(right_step_time_IMU_value)
            
                right_step_iterator_IMU = right_step_iterator_IMU + 1
        else: #i.e. right heel on occurs first 
            right_step_time_IMU_array = (LEFT_heel_on_IMU_TIMESTAMPS) - (RIGHT_heel_on_IMU_TIMESTAMPS)
        
            left_step_time_iterator_IMU = 1
            left_step_time_IMU_array = []
        
            while left_step_time_iterator_IMU <= len(RIGHT_heel_on_IMU_TIMESTAMPS) - 1:
                left_step_time_IMU_value = RIGHT_heel_on_IMU_TIMESTAMPS[left_step_time_iterator_IMU] - LEFT_heel_on_IMU_TIMESTAMPS[left_step_time_iterator_IMU - 1]
                left_step_time_IMU_array.append(left_step_time_IMU_value)
            
                left_step_time_iterator_IMU = left_step_time_iterator_IMU + 1
        

        left_step_time_IMU_array = np.array(left_step_time_IMU_array)
        left_step_time_IMU_std = np.std(left_step_time_IMU_array)
        left_step_time_IMU = np.sum(left_step_time_IMU_array)/len(left_step_time_IMU_array)
    
        right_step_time_IMU_array = np.array(right_step_time_IMU_array)
        right_step_time_IMU_std = np.std(right_step_time_IMU_array)
        right_step_time_IMU = np.sum(right_step_time_IMU_array)/len(right_step_time_IMU_array)

        #NOW CALCULATE CADENCE 
        #in form of cycles/minute
        left_CADENCE_IMU_array = 60/left_gait_cycle_array_IMU
        left_CADENCE_IMU_std = np.std(left_CADENCE_IMU_array)
        left_CADENCE_IMU = np.sum(left_CADENCE_IMU_array)/len(left_CADENCE_IMU_array)
    
        right_CADENCE_IMU_array = 60/right_gait_cycle_array_IMU
        right_CADENCE_IMU_std = np.std(right_CADENCE_IMU_array)
        right_CADENCE_IMU = np.sum(right_CADENCE_IMU_array)/len(right_CADENCE_IMU_array)
    
        #NOW FINALLY CALCULATE DOUBLE SUPPORT PARAMETER
        #START WITH LEFT LEG
        #the definition for left double support is right-toe-off samples - left heel on samples 
        left_check_rightTOE_IMU_index = RIGHT_toe_off_IMU_TIMESTAMPS[0]
        left_check_leftHEEL_IMU_index = LEFT_heel_on_IMU_TIMESTAMPS[0]
    
        if left_check_leftHEEL_IMU_index < left_check_rightTOE_IMU_index: #left heel on happens first
        
            left_double_support_IMU_array = RIGHT_toe_off_IMU_TIMESTAMPS - LEFT_heel_on_IMU_TIMESTAMPS
        else: #right toe off happens first
            left_double_iterator_IMU = 1
        
            left_double_support_IMU_array = []
            while left_double_iterator_IMU <= len(RIGHT_toe_off_IMU_TIMESTAMPS) - 1:
            
                left_double_support_value_IMU = RIGHT_toe_off_IMU_TIMESTAMPS[left_double_iterator_IMU] - LEFT_heel_on_IMU_TIMESTAMPS[left_double_iterator_IMU - 1]
                left_double_support_IMU_array.append(left_double_support_value_IMU)
            
                left_double_iterator_IMU = left_double_iterator_IMU + 1
            
        #NOW DO FOR RIGHT LEG
        #definition for right double support is left toe off samples - right heel on samples
        right_check_leftTOE_IMU_index = LEFT_toe_off_IMU_TIMESTAMPS[0]
        right_check_rightHEEL_IMU_index = RIGHT_heel_on_IMU_TIMESTAMPS[0]
    
        if right_check_rightHEEL_IMU_index < right_check_leftTOE_IMU_index: #right heel on happens first 
        
            right_double_support_IMU_array = LEFT_toe_off_IMU_TIMESTAMPS - RIGHT_heel_on_IMU_TIMESTAMPS
        else: #left toe off happens first 
            right_double_iterator_IMU = 1
        
            right_double_support_IMU_array = []
            while right_double_iterator_IMU <= len(LEFT_toe_off_IMU_TIMESTAMPS) - 1:
            
                right_double_support_value_IMU = LEFT_toe_off_IMU_TIMESTAMPS[right_double_iterator_IMU] - RIGHT_heel_on_IMU_TIMESTAMPS[right_double_iterator_IMU - 1]
                right_double_support_IMU_array.append(right_double_support_value_IMU)
            
                right_double_iterator_IMU = right_double_iterator_IMU + 1
            
        left_double_support_IMU_array = np.array(left_double_support_IMU_array)
        left_double_support_IMU_std = np.std(left_double_support_IMU_array)
        left_double_support_IMU = np.sum(left_double_support_IMU_array)/len(left_double_support_IMU_array)
    
        right_double_support_IMU_array = np.array(right_double_support_IMU_array)
        right_double_support_IMU_std = np.std(right_double_support_IMU_array)
        right_double_support_IMU = np.sum(right_double_support_IMU_array)/len(right_double_support_IMU_array)
        
        #FINALLY, CALCULATE PERCENTAGES
        left_stance_percentage_IMU = (stance_phase_left_IMU/left_gait_cycle_IMU)*100
        right_stance_percentage_IMU = (stance_phase_right_IMU/right_gait_cycle_IMU)*100
    
        left_swing_percentage_IMU = (swing_phase_left_IMU/left_gait_cycle_IMU)*100
        right_swing_percentage_IMU = (swing_phase_right_IMU/right_gait_cycle_IMU)*100
    
        left_single_support_percentage_IMU = (single_support_left_IMU/left_gait_cycle_IMU)*100
        right_single_support_percentage_IMU = (single_support_right_IMU/right_gait_cycle_IMU)*100
    
        left_double_support_percentage_IMU = (left_double_support_IMU/left_gait_cycle_IMU)*100
        right_double_support_percentage_IMU = (right_double_support_IMU/left_gait_cycle_IMU)*100
        
        #ALSO CALCULATE SYMMETRY RATIO USING ROBINSON INDEX
        stance_phase_SYMMETRY_IMU = abs((2*(stance_phase_left_IMU - stance_phase_right_IMU)/(stance_phase_left_IMU + stance_phase_right_IMU))*100)
    
        cycle_SYMMETRY_IMU = abs((2*(left_gait_cycle_IMU - right_gait_cycle_IMU)/(left_gait_cycle_IMU + right_gait_cycle_IMU))*100)
    
        #NOW ALL TEMPORAL PARAMETERS SHOULD BE CALCULATED
        #re-save all relevent params
        STANCE_PHASE_LEFT_TEMPORAL_IMU = stance_phase_left_IMU
        STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU = stance_phase_left_std_IMU
        STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE_IMU = left_stance_percentage_IMU
        
        STANCE_PHASE_RIGHT_TEMPORAL_IMU = stance_phase_right_IMU
        STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU = stance_phase_right_std_IMU
        STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE_IMU = right_stance_percentage_IMU
        
        SWING_PHASE_LEFT_TEMPORAL_IMU = swing_phase_left_IMU
        SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU = swing_phase_left_std_IMU
        SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE_IMU = left_swing_percentage_IMU
        
        SWING_PHASE_RIGHT_TEMPORAL_IMU = swing_phase_right_IMU
        SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU = swing_phase_right_std_IMU
        SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE_IMU = right_swing_percentage_IMU
        
        SINGLE_SUPPORT_LEFT_TEMPORAL_IMU = single_support_left_IMU
        SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU = single_support_left_std_IMU
        SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE_IMU = left_single_support_percentage_IMU
        
        SINGLE_SUPPORT_RIGHT_TEMPORAL_IMU = single_support_right_IMU
        SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU = single_support_right_std_IMU
        SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE_IMU = right_single_support_percentage_IMU
        
        GAIT_CYCLE_LEFT_TEMPORAL_IMU = left_gait_cycle_IMU
        GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU = left_gait_cycle_std_IMU
        
        GAIT_CYCLE_RIGHT_TEMPORAL_IMU = right_gait_cycle_IMU
        GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU = right_gait_cycle_std_IMU
        
        LEFT_STEP_TIME_TEMPORAL_IMU = left_step_time_IMU
        LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU = left_step_time_IMU_std
        
        RIGHT_STEP_TIME_TEMPORAL_IMU = right_step_time_IMU
        RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU = right_step_time_IMU_std
        
        LEFT_CADENCE_TEMPORAL_IMU = left_CADENCE_IMU
        LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU = left_CADENCE_IMU_std
        
        RIGHT_CADENCE_TEMPORAL_IMU = right_CADENCE_IMU
        RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU = right_CADENCE_IMU_std
        
        LEFT_DOUBLE_SUPPORT_TEMPORAL_IMU = left_double_support_IMU
        LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU = left_double_support_IMU_std
        LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_IMU = left_double_support_percentage_IMU
        
        RIGHT_DOUBLE_SUPPORT_TEMPORAL_IMU = right_double_support_IMU
        RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU = right_double_support_IMU_std
        RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_IMU = right_double_support_percentage_IMU
        
        STANCE_PHASE_SYMMETRY_IMU = stance_phase_SYMMETRY_IMU
    
        CYCLE_SYMMETRY_IMU = cycle_SYMMETRY_IMU
            
            
    #NOW THAT IMU CALCULATION FUNCTION IS DEFINED, CAN CALL ON IT HERE TO GET OUTPUTS
    IMU_Calculations() #THIS CALLS THE ABOVE FUNCTION, DOES ALL THE MATH, AND NOW ALL THE VARIABLES EXIST AND CAN BE STORED IN A CSV
    
    #NOW parameters are calculated using both the FSR's and the IMU: can save in csv file
    #FIRST CHECK IF NEW USER OR RETURNING USER BEFORE SAVING THE FILE
    temporal_parameter_data = {'Left Stance Phase FSR': STANCE_PHASE_LEFT_TEMPORAL_FSR, 'Left Stance Phase IMU': STANCE_PHASE_LEFT_TEMPORAL_IMU, \
        'Right Stance Phase FSR': STANCE_PHASE_RIGHT_TEMPORAL_FSR, 'Right Stance Phase IMU': STANCE_PHASE_RIGHT_TEMPORAL_IMU, \
            'Left Swing Phase FSR': SWING_PHASE_LEFT_TEMPORAL_FSR, 'Left Swing Phase IMU': SWING_PHASE_LEFT_TEMPORAL_IMU, \
                'Right Swing Phase FSR': SWING_PHASE_RIGHT_TEMPORAL_FSR, 'Right Swing Phase IMU': SWING_PHASE_RIGHT_TEMPORAL_IMU, \
                    'Left Single Support FSR': SINGLE_SUPPORT_LEFT_TEMPORAL_FSR, 'Left Single Support IMU': SINGLE_SUPPORT_LEFT_TEMPORAL_IMU, \
                        'Right Single Support FSR': SINGLE_SUPPORT_RIGHT_TEMPORAL_FSR, 'Right Single Support IMU': SINGLE_SUPPORT_RIGHT_TEMPORAL_IMU, \
                            'Left Gait Cycle FSR': GAIT_CYCLE_LEFT_TEMPORAL_FSR, 'Left Gait Cycle IMU': GAIT_CYCLE_LEFT_TEMPORAL_IMU, \
                                'Right Gait Cycle FSR': GAIT_CYCLE_RIGHT_TEMPORAL_FSR, 'Right Gait Cycle IMU': GAIT_CYCLE_RIGHT_TEMPORAL_IMU, \
                                    'Left Step Time FSR': LEFT_STEP_TIME_TEMPORAL_FSR, 'Left Step Time IMU': LEFT_STEP_TIME_TEMPORAL_IMU,
                                        'Right Step Time FSR': RIGHT_STEP_TIME_TEMPORAL_FSR, 'Right Step Time IMU': RIGHT_STEP_TIME_TEMPORAL_IMU,\
                                            'Left Cadence FSR': LEFT_CADENCE_TEMPORAL_FSR, 'Left Cadence IMU': LEFT_CADENCE_TEMPORAL_IMU, 
                                                'Right Cadence FSR': RIGHT_CADENCE_TEMPORAL_FSR, 'Right Cadence IMU':  RIGHT_CADENCE_TEMPORAL_IMU,\
                                                    'Left Double Support FSR': LEFT_DOUBLE_SUPPORT_TEMPORAL_FSR, 'Left Double Support IMU': LEFT_DOUBLE_SUPPORT_TEMPORAL_IMU, \
                                                        'Right Double Support FSR': RIGHT_DOUBLE_SUPPORT_TEMPORAL_FSR, 'Right Double Support IMU': RIGHT_DOUBLE_SUPPORT_TEMPORAL_IMU,
                                                            'Stance Symmetry FSR': STANCE_PHASE_SYMMETRY_FSR, 'Stance Symmetry IMU': STANCE_PHASE_SYMMETRY_IMU,
                                                                'Cycle Symmetry FSR': CYCLE_SYMMETRY_FSR, 'Cycle Symmetry IMU': CYCLE_SYMMETRY_IMU}
    
    #create separate dictionary for the standard deviations and a new data frame and then append to the old data frame to make csv formatting nicer 
    #IMPORTANT: EACH ELEMENT IN A DICTIONARY MUST POSSES ITS OWN UNIQUE KEY ('std' is not unique when used repeatedly and thus after the first mention of 'std', the rest did not show in the csv)
    
    temporal_parameter_data_STD = {'Left Stance Phase FSR': STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Stance Phase IMU': STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU, \
        'Right Stance Phase FSR': STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Stance Phase IMU': STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU, \
            'Left Swing Phase FSR': SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Swing Phase IMU': SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                'Right Swing Phase FSR': SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Swing Phase IMU': SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                    'Left Single Support FSR': SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Single Support IMU': SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                        'Right Single Support FSR': SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Single Support IMU': SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                            'Left Gait Cycle FSR': GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Gait Cycle IMU': GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                                'Right Gait Cycle FSR': GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Gait Cycle IMU': GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                                    'Left Step Time FSR': LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR , 'Left Step Time IMU': LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU, 
                                        'Right Step Time FSR': RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Step Time IMU': RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_IMU,\
                                            'Left Cadence FSR': LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Cadence IMU': LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU,
                                                'Right Cadence FSR': RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Cadence IMU': RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_IMU,\
                                                    'Left Double Support FSR': LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Left Double Support IMU': LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU, \
                                                        'Right Double Support FSR': RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR, 'Right Double Support IMU': RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_IMU,
                                                            'Stance Symmetry FSR': 0, 'Stance Symmetry IMU': 0,
                                                                'Cycle Symmetry FSR': 0, 'Cycle Symmetry IMU': 0}
    
    TEMPORAL_PARAMETER_DATA_TABLE = pd.DataFrame(data = temporal_parameter_data, index = [0]) #need to use this index thing since technically all the values in the data frame are scalars
    standard_deviation_data_table = pd.DataFrame(data = temporal_parameter_data_STD, index = [0])
    
    #NOW APPEND THE STD DATA TO THE FIRST DATA FRAME
    TEMPORAL_PARAMETER_DATA_TABLE = TEMPORAL_PARAMETER_DATA_TABLE.append(standard_deviation_data_table) #NOW SHOULD BE IN PROPER FORMAT FOR CSV FILE
    
    #testing if new or returning user to be able to save file properly 
    new_user1 = emailEntry.get()
    returning_user1 = login_Entry.get()

    if len(new_user1) > 0 and len(returning_user1) == 0:
    
        TEMPORAL_PARAMETER_DATA_TABLE.to_csv(f'{dir3}/{new_user1}_{date_time}_TEMPORALPARAMETER.csv')

    elif len(returning_user1) > 0 and len(new_user1) == 0:

        TEMPORAL_PARAMETER_DATA_TABLE.to_csv(f'{returning_user1}_UserData/{returning_user1}_IMU_FSR_Parameters/{returning_user1}_{date_time}_TEMPORALPARAMETER.csv')

    
    #AFTER THE DATA FILE HAS BEEN GENERATED AND SAVED, NEED TO CHANGE THE FORMATTING OF THE DATA TO MAKE IT BETTER TO DISPLAY ON SCREEN
    #AKA A FLOAT WITH ONLY 2 NUMBERS AFTER THE DECIMAL
    
    #for now, since the IMU data seems to be better and more reliable, I WILL DISPLAY IMU VALUES FOR THE PARAMETERS
    #IF THE NEW FSR's WORK BETTER, I CAN DISPLAY AN AVERAGE BETWEEN FSR AND IMU (FSR+IMU)/2
    global STANCE_PHASE_LEFT_TEMPORAL
    global STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION
    global STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE
    STANCE_PHASE_LEFT_TEMPORAL = "{:.2f}".format(STANCE_PHASE_LEFT_TEMPORAL_FSR)
    STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR)
    STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE = "{:.2f}".format(STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE_FSR)
    
    global STANCE_PHASE_RIGHT_TEMPORAL
    global STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION
    global  STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE
    STANCE_PHASE_RIGHT_TEMPORAL = "{:.2f}".format(STANCE_PHASE_RIGHT_TEMPORAL_FSR)
    STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR)
    STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE = "{:.2f}".format(STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE_FSR)
    
    global SWING_PHASE_LEFT_TEMPORAL
    global SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION
    global SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE
    SWING_PHASE_LEFT_TEMPORAL = "{:.2f}".format(SWING_PHASE_LEFT_TEMPORAL_FSR)
    SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR)
    SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE = "{:.2f}".format(SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE_FSR)
    
    global SWING_PHASE_RIGHT_TEMPORAL
    global SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION
    global SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE
    SWING_PHASE_RIGHT_TEMPORAL = "{:.2f}".format(SWING_PHASE_RIGHT_TEMPORAL_FSR)
    SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR)
    SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE = "{:.2f}".format(SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE_FSR)
    
    global SINGLE_SUPPORT_LEFT_TEMPORAL
    global SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION
    global SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE
    SINGLE_SUPPORT_LEFT_TEMPORAL = "{:.2f}".format(SINGLE_SUPPORT_LEFT_TEMPORAL_FSR)
    SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR)
    SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE = "{:.2f}".format(SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE_FSR)
    
    global SINGLE_SUPPORT_RIGHT_TEMPORAL
    global SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION
    global SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE
    SINGLE_SUPPORT_RIGHT_TEMPORAL = "{:.2f}".format(SINGLE_SUPPORT_RIGHT_TEMPORAL_FSR)
    SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR)
    SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE = "{:.2f}".format(SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE_FSR)
    
    global GAIT_CYCLE_LEFT_TEMPORAL
    global GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION
    GAIT_CYCLE_LEFT_TEMPORAL = "{:.2f}".format(GAIT_CYCLE_LEFT_TEMPORAL_FSR)
    GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global GAIT_CYCLE_RIGHT_TEMPORAL
    global GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION
    GAIT_CYCLE_RIGHT_TEMPORAL = "{:.2f}".format(GAIT_CYCLE_RIGHT_TEMPORAL_FSR)
    GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global LEFT_STEP_TIME_TEMPORAL
    global LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION
    LEFT_STEP_TIME_TEMPORAL = "{:.2f}".format(LEFT_STEP_TIME_TEMPORAL_FSR)
    LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global RIGHT_STEP_TIME_TEMPORAL
    global RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION
    RIGHT_STEP_TIME_TEMPORAL = "{:.2f}".format(RIGHT_STEP_TIME_TEMPORAL_FSR)
    RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global LEFT_CADENCE_TEMPORAL
    global LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION
    LEFT_CADENCE_TEMPORAL = "{:.2f}".format(LEFT_CADENCE_TEMPORAL_FSR)
    LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global RIGHT_CADENCE_TEMPORAL
    global RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION
    RIGHT_CADENCE_TEMPORAL = "{:.2f}".format(RIGHT_CADENCE_TEMPORAL_FSR)
    RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION_FSR)
    
    global LEFT_DOUBLE_SUPPORT_TEMPORAL
    global LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION
    global LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE
    LEFT_DOUBLE_SUPPORT_TEMPORAL = "{:.2f}".format(LEFT_DOUBLE_SUPPORT_TEMPORAL_FSR)
    LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR)
    LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE = "{:.2f}".format(LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_FSR)
    
    global RIGHT_DOUBLE_SUPPORT_TEMPORAL
    global RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION
    global RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE
    RIGHT_DOUBLE_SUPPORT_TEMPORAL = "{:.2f}".format(RIGHT_DOUBLE_SUPPORT_TEMPORAL_FSR)
    RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION = "{:.2f}".format(RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION_FSR)
    RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE = "{:.2f}".format(RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE_FSR)
    
    global STANCE_SYMMETRY_TEMPORAL
    STANCE_SYMMETRY_TEMPORAL = "{:.2f}".format(STANCE_PHASE_SYMMETRY_FSR)
    
    global CYCLE_SYMMETRY_TEMPORAL
    CYCLE_SYMMETRY_TEMPORAL = "{:.2f}".format(CYCLE_SYMMETRY_FSR)
    
    #NOW WITH ALL THE MATH DONE AND ALL PARAMETERS CALCULATED, CAN WORK ON DISPLAYING IN A TABLE
    #ALSO AT THIS POINT SHOULD IMPORT DATABASE OF NORMATIVE VALUES

    global normative_data_indentifier_AGE
    global normative_data_indentifier_GENDER

    if patientAge <= 30:
        normative_data_indentifier_AGE = 1 #can pull normative data using this value from backend table to display along temporal calculated parameters
    elif patientAge > 30 and patientAge <= 40:
        normative_data_indentifier_AGE = 2
    elif patientAge > 40 and patientAge <= 50:
        normative_data_indentifier_AGE = 3
    else: #if patient is 51+ years of age
        normative_data_indentifier_AGE = 4
    
    normative_data_indentifier_test_gender = patientGender

    if "Male" in normative_data_indentifier_test_gender:
        normative_data_indentifier_GENDER = "m"
    elif "Female" in normative_data_indentifier_test_gender:
        normative_data_indentifier_GENDER = "f"
    else: #if they pick other gender, just use male identifier and pull the male data from the database 
        normative_data_indentifier_GENDER = "m"

    #was going to use gender as identifier as well to pull more specific data from the normative database, however,
    #the current input is open entry field and will be too difficult to create a robust method to always get it right. So will display age range data for both M and F in the table

    #JUST REDEFINE IDENTIFIERS FOR NO REASON
    global identifier_AGE
    global identifier_GENDER
    
    identifier_AGE = normative_data_indentifier_AGE
    identifier_GENDER = normative_data_indentifier_GENDER
    #all the comparison have to be done inside the function otherwise app will not compile. Dictionary can be defined outside the function and still accessed though
    
    ###HAVE TO MAKE ALL LABELS GLOBAL VARIABLES SO CAN BE CLEARED BY START NEW TEST FUNCTION
    global parameters_label
    global left_leg_label
    global right_leg_label
    global normative_data_label
    global step_time_label
    global step_time_units_label
    global cycle_time_label
    global cycle_time_units_label
    global cadence_label
    global cadence_units_label
    global swing_time_label
    global swing_time_units_label
    global stance_time_label
    global stance_time_units_label
    global single_support_time_label
    global single_support_time_units_label
    global double_support_time_label
    global double_support_time_units_label
    global stance_symmetry_label
    global swing_symmetry_label
    global step_time_left_measured
    global cycle_time_left_measured
    global cadence_left_measured
    global swing_time_left_measured
    global stance_time_left_measured
    global single_support_left_measured
    global double_support_left_measured
    global stance_symmetry_measured
    global cycle_symmetry_measured
    global step_time_right_measured
    global cycle_time_right_measured
    global cadence_right_measured
    global swing_time_right_measured
    global stance_time_right_measured
    global single_support_right_measured
    global double_support_right_measured
    global normative_step_time
    global normative_cycle_time
    global normative_cadence
    global normative_swing_time
    global normative_stance_time
    global normative_single_time
    global normative_double_time
    
    ##BUILD UP THE FRONT END HERE
    ##TEST SECTION FOR FRONT END - COPY AND PASTE INTO calculate_gait FUNCTION WHEN SATISFIED
    #REMEMBER WITHIN A FUNCTION, need to use root.update() command to make the labels show up
    parameters_label = Label(page7, text = "Parameters", font = ('Helvetica', 15, 'underline', 'bold'), bg = 'gray89', fg = 'midnight blue')
    parameters_label.place(relx = 0.25, rely = 0.12, anchor = "center")
    root.update()
    
    #need to check here which legs are proesthetic and which legs are intact for the LEG COLUMN HEADERS
    amputation_side_string = str(patientAmputation) #THIS VARIABLE SHOULD EXIST NO MATTER WHAT, WHETHER FROM PAGE 2 ENTRY OR READ IN FROM BIODATA CSV FILE

    if "Left" in amputation_side_string and "Right" not in amputation_side_string:
        amputation_SIDE = "LEFT"
    elif "Right" in amputation_side_string and "Left" not in amputation_side_string:
        amputation_SIDE = "RIGHT"
    elif "Left" in amputation_side_string and "Right" in amputation_side_string:
        amputation_SIDE = "BOTH"
    else:
        amputation_SIDE = "NEITHER"
        
    if amputation_SIDE == "LEFT":
        left_leg_stat = "Prosthesis"
        right_leg_stat = "Intact"
    elif amputation_SIDE == "RIGHT":
        left_leg_stat = "Intact"
        right_leg_stat = "Prosthesis"
    elif amputation_SIDE == "BOTH":
        left_leg_stat = "Prosthesis"
        right_leg_stat = "Prosthesis"
    else:
        left_leg_stat = "Intact"
        right_leg_stat = "Intact"

    #REMEMBER, THE LEFT AND RIGHT LEG LABELS NEED TO CHANGE BASED ON WHICH SIDE THE PATIENT HAS AN AMPUTATION ON (THIS IS EASY) - just use f string
    left_leg_label = Label(page7, text = f"Left Leg ({left_leg_stat})", font = ('Helvetica', 15, 'underline', 'bold'), bg = 'gray89', fg = 'red4')
    left_leg_label.place(relx = 0.42, rely = 0.12, anchor = "center")
    root.update()

    right_leg_label = Label(page7, text = f"Right Leg ({right_leg_stat})", font = ('Helvetica', 15, 'underline', 'bold'), bg = 'gray89', fg = 'blue')
    right_leg_label.place(relx = 0.58, rely = 0.12, anchor = "center")
    root.update()

    normative_data_label = Label(page7, text = "Normative Data", font = ('Helvetica', 15, 'underline', 'bold'), bg = 'gray89', fg = 'midnight blue')
    normative_data_label.place(relx = 0.73, rely = 0.12, anchor = "center")
    root.update()

    #now create the sub labels for the parameters column
    step_time_label = Label(page7, text = "Step Time (+/- SD):", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    step_time_label.place(relx = 0.2825, rely = 0.18, anchor = "e")
    root.update()
    step_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    step_time_units_label.place(relx = 0.25, rely = 0.20, anchor = "center")
    root.update()

    cycle_time_label = Label(page7, text = "Cycle Time (+/- SD):", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    cycle_time_label.place(relx = 0.2825, rely = 0.26, anchor = "e")
    root.update()
    cycle_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    cycle_time_units_label.place(relx = 0.25, rely = 0.28, anchor = "center")
    root.update()

    cadence_label = Label(page7, text = "Cadence (+/- SD):", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    cadence_label.place(relx = 0.2825, rely = 0.34, anchor = "e")
    root.update()
    cadence_units_label = Label(page7, text = "(cycles/minute)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    cadence_units_label.place(relx = 0.25, rely = 0.36, anchor = "center")
    root.update()

    swing_time_label = Label(page7, text = "Swing Time (+/- SD) / % Cycle:", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    swing_time_label.place(relx = 0.2825, rely = 0.42, anchor = "e")
    root.update()
    swing_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    swing_time_units_label.place(relx = 0.25, rely = 0.44, anchor = "center")
    root.update()

    stance_time_label = Label(page7, text = "Stance Time (+/- SD) / % Cycle:", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    stance_time_label.place(relx = 0.2825, rely = 0.50, anchor = "e")
    root.update()
    stance_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    stance_time_units_label.place(relx = 0.25, rely = 0.52, anchor = "center")
    root.update()

    single_support_time_label = Label(page7, text = "Single Support Time (+/- SD) / % Cycle:", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    single_support_time_label.place(relx = 0.2825, rely = 0.58, anchor = "e")
    root.update()
    single_support_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    single_support_time_units_label.place(relx = 0.25, rely = 0.60, anchor = "center")
    root.update()

    double_support_time_label = Label(page7, text = "Double Support Time (+/- SD) / % Cycle:", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    double_support_time_label.place(relx = 0.2825, rely = 0.66, anchor = "e")
    root.update()
    double_support_time_units_label = Label(page7, text = "(seconds)", font = ('Helvetica', 10), bg = 'gray89', fg = 'midnight blue')
    double_support_time_units_label.place(relx = 0.25, rely = 0.68, anchor = "center")
    root.update()
    
    stance_symmetry_label = Label(page7, text = "Stance Symmetry Ratio (Robinson Index):", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    stance_symmetry_label.place(relx = 0.2825, rely = 0.74, anchor = "e")
    root.update()
    
    swing_symmetry_label = Label(page7, text = "Cycle Symmetry Ratio (Robinson Index):", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    swing_symmetry_label.place(relx = 0.2825, rely = 0.79, anchor = "e")
    root.update()
    
    #NOW THAT SKELETON LABELS ARE DONE, ADD IN CALCULATED PARAMETER VALUES FOR LEFT AND RIGHT LEG
    #START WITH LEFT SIDE 
    step_time_left_measured = Label(page7, text = f"{LEFT_STEP_TIME_TEMPORAL} (+/- {LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    step_time_left_measured.place(relx = 0.42, rely = 0.18, anchor = "center")
    root.update()
    
    cycle_time_left_measured = Label(page7, text = f"{GAIT_CYCLE_LEFT_TEMPORAL} (+/- {GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    cycle_time_left_measured.place(relx = 0.42, rely = 0.26, anchor = "center")
    root.update()
    
    cadence_left_measured = Label(page7, text = f"{LEFT_CADENCE_TEMPORAL} (+/- {LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    cadence_left_measured.place(relx = 0.42, rely = 0.34, anchor = "center")
    root.update()
    
    swing_time_left_measured = Label(page7, text = f"{SWING_PHASE_LEFT_TEMPORAL} (+/- {SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    swing_time_left_measured.place(relx = 0.42, rely = 0.42, anchor = "center")
    root.update()
    
    stance_time_left_measured = Label(page7, text = f"{STANCE_PHASE_LEFT_TEMPORAL} (+/- {STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    stance_time_left_measured.place(relx = 0.42, rely = 0.50, anchor = "center")
    root.update()
    
    single_support_left_measured = Label(page7, text = f"{SINGLE_SUPPORT_LEFT_TEMPORAL} (+/- {SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    single_support_left_measured.place(relx = 0.42, rely = 0.58, anchor = "center")
    root.update()
    
    double_support_left_measured = Label(page7, text = f"{LEFT_DOUBLE_SUPPORT_TEMPORAL} (+/- {LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION}) / {LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'red4')
    double_support_left_measured.place(relx = 0.42, rely = 0.66, anchor = "center")
    root.update()
    
    #####SECTION FOR SYMMETRY PARAMETERS - ABSOLUTE VALUE SO NOT SPECIFIC TO A LEG#################################
    
    stance_symmetry_measured = Label(page7, text = f"{STANCE_SYMMETRY_TEMPORAL}", font = ('Helvetica', 13), bg = 'gray89', fg = 'gray5') #these are centered and in black
    stance_symmetry_measured.place(relx = 0.50, rely = 0.74, anchor = "center")
    root.update()
    
    cycle_symmetry_measured = Label(page7, text = f"{CYCLE_SYMMETRY_TEMPORAL}", font = ('Helvetica', 13), bg = 'gray89', fg = 'gray5')
    cycle_symmetry_measured.place(relx = 0.50, rely = 0.79, anchor = "center")
    root.update()
    
    #NOW DO RIGHT SIDE
    step_time_right_measured = Label(page7, text = f"{RIGHT_STEP_TIME_TEMPORAL} (+/- {RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    step_time_right_measured.place(relx = 0.58, rely = 0.18, anchor = "center")
    root.update()
    
    cycle_time_right_measured = Label(page7, text = f"{GAIT_CYCLE_RIGHT_TEMPORAL} (+/- {GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    cycle_time_right_measured.place(relx = 0.58, rely = 0.26, anchor = "center")
    root.update()
    
    cadence_right_measured = Label(page7, text = f"{RIGHT_CADENCE_TEMPORAL} (+/- {RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION})", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    cadence_right_measured.place(relx = 0.58, rely = 0.34, anchor = "center")
    root.update()
    
    swing_time_right_measured = Label(page7, text = f"{SWING_PHASE_RIGHT_TEMPORAL} (+/- {SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    swing_time_right_measured.place(relx = 0.58, rely = 0.42, anchor = "center")
    root.update()
    
    stance_time_right_measured = Label(page7, text = f"{STANCE_PHASE_RIGHT_TEMPORAL} (+/- {STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    stance_time_right_measured.place(relx = 0.58, rely = 0.50, anchor = "center")
    root.update()
    
    single_support_right_measured = Label(page7, text = f"{SINGLE_SUPPORT_RIGHT_TEMPORAL} (+/- {SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    single_support_right_measured.place(relx = 0.58, rely = 0.58, anchor = "center")
    root.update()
    
    double_support_right_measured = Label(page7, text = f"{RIGHT_DOUBLE_SUPPORT_TEMPORAL} (+/- {RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION}) / {RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'blue')
    double_support_right_measured.place(relx = 0.58, rely = 0.66, anchor = "center")
    root.update()
    
    ##FINALLY, IMPORT CORRECT NORMATIVE DATA FROM THE DATABASE
    normative_step_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_step']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_step_STD']})", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_step_time.place(relx = 0.73, rely = 0.18, anchor = "center")
    root.update()
    
    normative_cycle_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cycle']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cycle_STD']})", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_cycle_time.place(relx = 0.73, rely = 0.26, anchor = "center")
    root.update()
    
    normative_cadence = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cadence']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cadence_STD']})", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_cadence.place(relx = 0.73, rely = 0.34, anchor = "center")
    root.update()
    
    normative_swing_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing_%']}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_swing_time.place(relx = 0.73, rely = 0.42, anchor = "center")
    root.update()
    
    normative_stance_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance_%']}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_stance_time.place(relx = 0.73, rely = 0.50, anchor = "center")
    root.update()
    
    normative_single_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single_%']}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_single_time.place(relx = 0.73, rely = 0.58, anchor = "center")
    root.update()
    
    normative_double_time = Label(page7, text = f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double_%']}%", font = ('Helvetica', 13), bg = 'gray89', fg = 'midnight blue')
    normative_double_time.place(relx = 0.73, rely = 0.66, anchor = "center")
    root.update()
        
        
    #except:
        #BASICALLY IF SOMETHING GOES WRONG AND THE PARAMETERS ARE NOT CALCULATED, display a try collecting data again message I guess
        #bad_data_Label = Label(page7, text = "ERROR: BAD DATA. Please ensure proper sensor connection and run the test again.", font = ('Helvetica', 20), fg = 'red4', bg = 'gray89')
        #bad_data_Label.place(relx = 0.5, rely = 0.3, anchor = "center")
        #root.update()
        #time.sleep(8)
        #bad_data_Label.destroy()
        #root.update()

normative_data_dictionary = {} #curly braces defines empty dictionary that can now be indexed with a key for each parmaeter, gender, and age range
#insert each normative data value into the dictionary which can be called and compared in the parameters page based on the patientAge identifyer

#here will begin the horribly long ass section of manually adding in all normative data into the backend via the dictionary 
#FORMATTING: 1_gender_parameter where 1 corresponds to specific age grouping, gender comes from input
# 1 = 30 or under age, 2 = 30 - 39, 3 = 40 - 49, 4 = 50 and older

#IMPORT FIRST AGE GROUP - reformat this data to two decimal places to make presentation nicer: "{:.2f}".format()
normative_data_dictionary['1_m_cycle'] = "{:.2f}".format(1098/1000)
normative_data_dictionary['1_m_cycle_STD'] = "{:.2f}".format(67.98/1000)
normative_data_dictionary['1_m_stance'] = "{:.2f}".format(669.37/1000)
normative_data_dictionary['1_m_stance_STD'] = "{:.2f}".format(46.28/1000)
normative_data_dictionary['1_m_stance_%'] = "{:.2f}".format(60.94)
normative_data_dictionary['1_m_swing'] = "{:.2f}".format(428.96/1000)
normative_data_dictionary['1_m_swing_STD'] = "{:.2f}".format(26.14/1000)
normative_data_dictionary['1_m_swing_%'] = "{:.2f}".format(39.08)
normative_data_dictionary['1_m_cadence'] = "{:.2f}".format(54.84) #cycles/min
normative_data_dictionary['1_m_cadence_STD'] = "{:.2f}".format(3.29)
normative_data_dictionary['1_m_step'] = "{:.2f}".format(505/1000)
normative_data_dictionary['1_m_step_STD'] = "{:.2f}".format(76/1000)
normative_data_dictionary['1_m_single'] = "{:.2f}".format(405/1000)
normative_data_dictionary['1_m_single_STD'] = "{:.2f}".format(56/1000)
normative_data_dictionary['1_m_single_%'] = "{:.2f}".format(38.3)
normative_data_dictionary['1_m_double'] = "{:.2f}".format(302/1000)
normative_data_dictionary['1_m_double_STD'] = "{:.2f}".format(48/1000)
normative_data_dictionary['1_m_double_%'] = "{:.2f}".format(28)

normative_data_dictionary['1_f_cycle'] = "{:.2f}".format(1031.67/1000)
normative_data_dictionary['1_f_cycle_STD'] = "{:.2f}".format(69.98/1000)
normative_data_dictionary['1_f_stance'] = "{:.2f}".format(623.78/1000)
normative_data_dictionary['1_f_stance_STD'] = "{:.2f}".format(52.73/1000)
normative_data_dictionary['1_f_stance_%'] = "{:.2f}".format(60.41)
normative_data_dictionary['1_f_swing'] = "{:.2f}".format(407.87/1000)
normative_data_dictionary['1_f_swing_STD'] = "{:.2f}".format(23.07/1000)
normative_data_dictionary['1_f_swing_%'] = "{:.2f}".format(39.59)
normative_data_dictionary['1_f_cadence'] = "{:.2f}".format(58.41) #cycles/min
normative_data_dictionary['1_f_cadence_STD'] = "{:.2f}".format(3.71)
normative_data_dictionary['1_f_step'] = "{:.2f}".format(480/1000)
normative_data_dictionary['1_f_step_STD'] = "{:.2f}".format(67/1000)
normative_data_dictionary['1_f_single'] = "{:.2f}".format(345/1000)
normative_data_dictionary['1_f_single_STD'] = "{:.2f}".format(55/1000)
normative_data_dictionary['1_f_single_%'] = "{:.2f}".format(39)
normative_data_dictionary['1_f_double'] = "{:.2f}".format(260/1000)
normative_data_dictionary['1_f_double_STD'] = "{:.2f}".format(60/1000)
normative_data_dictionary['1_f_double_%'] = "{:.2f}".format(27.9)

#IMPORT SECOND AGE GROUP - "{:.2f}".format()
normative_data_dictionary['2_m_cycle'] = "{:.2f}".format(1115.58/1000)
normative_data_dictionary['2_m_cycle_STD'] = "{:.2f}".format(74.68/1000)
normative_data_dictionary['2_m_stance'] = "{:.2f}".format(684.74/1000)
normative_data_dictionary['2_m_stance_STD'] = "{:.2f}".format(57.15/1000)
normative_data_dictionary['2_m_stance_%'] = "{:.2f}".format(61.31)
normative_data_dictionary['2_m_swing'] = "{:.2f}".format(430.90/1000)
normative_data_dictionary['2_m_swing_STD'] = "{:.2f}".format(18.34/1000)
normative_data_dictionary['2_m_swing_%'] = "{:.2f}".format(38.69)
normative_data_dictionary['2_m_cadence'] = "{:.2f}".format(54.02) #cycles/min
normative_data_dictionary['2_m_cadence_STD'] = "{:.2f}".format(3.66)
normative_data_dictionary['2_m_step'] = "{:.2f}".format(500/1000)
normative_data_dictionary['2_m_step_STD'] = "{:.2f}".format(70/1000)
normative_data_dictionary['2_m_single'] = "{:.2f}".format(425/1000)
normative_data_dictionary['2_m_single_STD'] = "{:.2f}".format(47/1000)
normative_data_dictionary['2_m_single_%'] = "{:.2f}".format(37.2)
normative_data_dictionary['2_m_double'] = "{:.2f}".format(315/1000)
normative_data_dictionary['2_m_double_STD'] = "{:.2f}".format(35/1000)
normative_data_dictionary['2_m_double_%'] = "{:.2f}".format(24.8)

normative_data_dictionary['2_f_cycle'] = "{:.2f}".format(1013.63/1000)
normative_data_dictionary['2_f_cycle_STD'] = "{:.2f}".format(79.62/1000)
normative_data_dictionary['2_f_stance'] = "{:.2f}".format(618.67/1000)
normative_data_dictionary['2_f_stance_STD'] = "{:.2f}".format(58.53/1000)
normative_data_dictionary['2_f_stance_%'] = "{:.2f}".format(60.97)
normative_data_dictionary['2_f_swing'] = "{:.2f}".format(394.93/1000)
normative_data_dictionary['2_f_swing_STD'] = "{:.2f}".format(26.19/1000)
normative_data_dictionary['2_f_swing_%'] = "{:.2f}".format(39.03)
normative_data_dictionary['2_f_cadence'] = "{:.2f}".format(59.56) #cycles/min
normative_data_dictionary['2_f_cadence_STD'] = "{:.2f}".format(4.82)
normative_data_dictionary['2_f_step'] = "{:.2f}".format(470/1000)
normative_data_dictionary['2_f_step_STD'] = "{:.2f}".format(59/1000)
normative_data_dictionary['2_f_single'] = "{:.2f}".format(335/1000)
normative_data_dictionary['2_f_single_STD'] = "{:.2f}".format(45/1000)
normative_data_dictionary['2_f_single_%'] = "{:.2f}".format(37.3)
normative_data_dictionary['2_f_double'] = "{:.2f}".format(236/1000)
normative_data_dictionary['2_f_double_STD'] = "{:.2f}".format(35/1000)
normative_data_dictionary['2_f_double_%'] = "{:.2f}".format(26.6)

#IMPORT THIRD AGE GROUP
normative_data_dictionary['3_m_cycle'] = "{:.2f}".format(1053.75/1000)
normative_data_dictionary['3_m_cycle_STD'] = "{:.2f}".format(25.32/1000)
normative_data_dictionary['3_m_stance'] = "{:.2f}".format(634.25/1000)
normative_data_dictionary['3_m_stance_STD'] = "{:.2f}".format(16.28/1000)
normative_data_dictionary['3_m_stance_%'] = "{:.2f}".format(60.21)
normative_data_dictionary['3_m_swing'] = "{:.2f}".format(419.25/1000)
normative_data_dictionary['3_m_swing_STD'] = "{:.2f}".format(27.77/1000)
normative_data_dictionary['3_m_swing_%'] = "{:.2f}".format(39.77)
normative_data_dictionary['3_m_cadence'] = "{:.2f}".format(56.96) #cycles/min
normative_data_dictionary['3_m_cadence_STD'] = "{:.2f}".format(1.37)
normative_data_dictionary['3_m_step'] = "{:.2f}".format(498/1000)
normative_data_dictionary['3_m_step_STD'] = "{:.2f}".format(90/1000)
normative_data_dictionary['3_m_single'] = "{:.2f}".format(400/1000)
normative_data_dictionary['3_m_single_STD'] = "{:.2f}".format(55/1000)
normative_data_dictionary['3_m_single_%'] = "{:.2f}".format(38)
normative_data_dictionary['3_m_double'] = "{:.2f}".format(290/1000)
normative_data_dictionary['3_m_double_STD'] = "{:.2f}".format(48/1000)
normative_data_dictionary['3_m_double_%'] = "{:.2f}".format(24.3)

normative_data_dictionary['3_f_cycle'] = "{:.2f}".format(1036.38/1000)
normative_data_dictionary['3_f_cycle_STD'] = "{:.2f}".format(85.71/1000)
normative_data_dictionary['3_f_stance'] = "{:.2f}".format(632.96/1000)
normative_data_dictionary['3_f_stance_STD'] = "{:.2f}".format(58.26/1000)
normative_data_dictionary['3_f_stance_%'] = "{:.2f}".format(61.04)
normative_data_dictionary['3_f_swing'] = "{:.2f}".format(403.50/1000)
normative_data_dictionary['3_f_swing_STD'] = "{:.2f}".format(30.73/1000)
normative_data_dictionary['3_f_swing_%'] = "{:.2f}".format(38.97)
normative_data_dictionary['3_f_cadence'] = "{:.2f}".format(58.24) #cycles/min
normative_data_dictionary['3_f_cadence_STD'] = "{:.2f}".format(4.37)
normative_data_dictionary['3_f_step'] = "{:.2f}".format(460/1000)
normative_data_dictionary['3_f_step_STD'] = "{:.2f}".format(63/1000)
normative_data_dictionary['3_f_single'] = "{:.2f}".format(350/1000)
normative_data_dictionary['3_f_single_STD'] = "{:.2f}".format(50/1000)
normative_data_dictionary['3_f_single_%'] = "{:.2f}".format(38)
normative_data_dictionary['3_f_double'] = "{:.2f}".format(250/1000)
normative_data_dictionary['3_f_double_STD'] = "{:.2f}".format(45/1000)
normative_data_dictionary['3_f_double_%'] = "{:.2f}".format(25)

#IMPORT FOURTH AGE GROUP
normative_data_dictionary['4_m_cycle'] = "{:.2f}".format(1101.50/1000)
normative_data_dictionary['4_m_cycle_STD'] = "{:.2f}".format(110.86/1000)
normative_data_dictionary['4_m_stance'] = "{:.2f}".format(667.00/1000)
normative_data_dictionary['4_m_stance_STD'] = "{:.2f}".format(80.55/1000)
normative_data_dictionary['4_m_stance_%'] = "{:.2f}".format(60.46)
normative_data_dictionary['4_m_swing'] = "{:.2f}".format(434.50/1000)
normative_data_dictionary['4_m_swing_STD'] = "{:.2f}".format(31.67/1000)
normative_data_dictionary['4_m_swing_%'] = "{:.2f}".format(39.54)
normative_data_dictionary['4_m_cadence'] = "{:.2f}".format(54.89) #cycles/min
normative_data_dictionary['4_m_cadence_STD'] = "{:.2f}".format(5.52)
normative_data_dictionary['4_m_step'] = "{:.2f}".format(590/1000)
normative_data_dictionary['4_m_step_STD'] = "{:.2f}".format(50/1000)
normative_data_dictionary['4_m_single'] = "{:.2f}".format(440/1000)
normative_data_dictionary['4_m_single_STD'] = "{:.2f}".format(30/1000)
normative_data_dictionary['4_m_single_%'] = "{:.2f}".format(37.1)
normative_data_dictionary['4_m_double'] = "{:.2f}".format(310/1000)
normative_data_dictionary['4_m_double_STD'] = "{:.2f}".format(50/1000)
normative_data_dictionary['4_m_double_%'] = "{:.2f}".format(26.3)

normative_data_dictionary['4_f_cycle'] = "{:.2f}".format(1119.88/1000)
normative_data_dictionary['4_f_cycle_STD'] = "{:.2f}".format(140.54/1000)
normative_data_dictionary['4_f_stance'] = "{:.2f}".format(704.25/1000)
normative_data_dictionary['4_f_stance_STD'] = "{:.2f}".format(105.09/1000)
normative_data_dictionary['4_f_stance_%'] = "{:.2f}".format(62.73)
normative_data_dictionary['4_f_swing'] = "{:.2f}".format(415.13/1000)
normative_data_dictionary['4_f_swing_STD'] = "{:.2f}".format(35.93/1000)
normative_data_dictionary['4_f_swing_%'] = "{:.2f}".format(37.22)
normative_data_dictionary['4_f_cadence'] = "{:.2f}".format(54.25) #cycles/min
normative_data_dictionary['4_f_cadence_STD'] = "{:.2f}".format(6.09)
normative_data_dictionary['4_f_step'] = "{:.2f}".format(530/1000)
normative_data_dictionary['4_f_step_STD'] = "{:.2f}".format(60/1000)
normative_data_dictionary['4_f_single'] = "{:.2f}".format(390/1000)
normative_data_dictionary['4_f_single_STD'] = "{:.2f}".format(60/1000)
normative_data_dictionary['4_f_single_%'] = "{:.2f}".format(37)
normative_data_dictionary['4_f_double'] = "{:.2f}".format(290/1000)
normative_data_dictionary['4_f_double_STD'] = "{:.2f}".format(60/1000)
normative_data_dictionary['4_f_double_%'] = "{:.2f}".format(27.14)


gait_parameters_button = Button(page7, text = "Calculate Gait Paramemters", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = calculate_gait)
gait_parameters_button.place(relx = 0.5, rely = 0.05, anchor = "center")
gait_parameters_button['state'] = DISABLED
#######################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 8

#FINALLY, THIS PAGE IS FOR PLOTTING THE GAIT CYCLE AVERAGES + STANDARD DEVIATIONS

def gait_cycle_function():
    
    #DISABLE THE BUTTON
    gait_cycle_plots_button['state'] = DISABLED

    #first, need to get the correct data sets for plotting - this will be the only tricky part 
    #this will also need to be inside the plot function
    #NEED: average gait cycle plots +/- STD for both legs 

    #so for this, need the LEFT HEEL ON AND TOE OFF INDEX POSITIONS, and THE RIGHT HEEL ON AND TOE OFF INDEX POSITIONS
        #this will come from the FSR algorithm as using FSR data only for these plots, so don't need what the IMU says

    LHS = LEFT_heel_on_array
    LTO = LEFT_toe_off_array

    RHS = RIGHT_heel_on_array
    RTO = RIGHT_toe_off_array #remember, this can't be accessed before the gait parameters are calculated since all the FSR event arrays won't exist until that algorithm is run
    #WILL BUILD IN BUTTON LOGIC TO MAKE SURE THIS IS THE CASE 
    
    #first resize to make all same length 
    LHS_length = len(LHS)
    LTO_length = len(LTO)
    
    RHS_length = len(RHS)
    RTO_length = len(RTO)
    
    GC_array_lengths = [LHS_length, LTO_length, RHS_length, RTO_length]
    GC_array_lengths_MINIMUM = min(GC_array_lengths)
    
    #now do the resize
    LHS = LHS[0:GC_array_lengths_MINIMUM]
    LTO = LTO[0:GC_array_lengths_MINIMUM]
    RHS = RHS[0:GC_array_lengths_MINIMUM]
    RTO = RTO[0:GC_array_lengths_MINIMUM]
    
    #######################LEFT####################%%%%%
    #start with LEFT GAIT CYCLES ALGORITHM
    
    left_length_iterator_case1 = 0
    left_length_iterator_case2 = 1
    
    left_event_positions = []
    
    #going to assume it will be basically impossible for HS and TO to happen at the same time
    if LHS[0] < LTO[0]: #i.e heel strike comes first for left foot
        while left_length_iterator_case1 <= len(LHS) - 1: #could use length of either, doesnt matter. Will be same length at this point 
            left_event_positions.append(LHS[left_length_iterator_case1])
            left_event_positions.append(LTO[left_length_iterator_case1])
            
            #now the even elements are the heel on's and the odd elements in the list are the toe offs
            
            left_length_iterator_case1 = left_length_iterator_case1 + 1
    elif LTO[0] < LHS[0]: #i.e to on happens first for left foot
        while left_length_iterator_case2 <= len(LTO) - 1: #this one has to be LTO since need to start at 1st index rather than 0th and will run out of space first with LTO
            left_event_positions.append(LHS[left_length_iterator_case2 - 1])
            left_event_positions.append(LTO[left_length_iterator_case2])
            
            left_length_iterator_case2 = left_length_iterator_case2 + 1
    else: #this is if they happen at the same time, which probably should never happen ever
        pass
    
    #now with the left_event_positions array, figured out how to break up into correct data sets from the initial data
    #now break up into odd and even arrays?
    #WE KNOW NOW FOR SURE THERE WILL BE AN EVEN LENGTH IN THIS ARRAY
    left_HS_index_array = left_event_positions[0::2]
    left_TO_index_array = left_event_positions[1::2] #THESE FOR SURE HAVE THE SAME LENGTH
    
    #now i think i can make a pandas data frame with the same number of columns as the length of one of either of the two arrays above
    #this is gonna be ugly as fack
    #each column needs to be its own dataframe, then can append all data frames together and will fill in NaN's in cases where not exact same length 
    #then can transpose ^T and take average and set exclude NaN's to get average of each column 
    
    #FIRST THE DATA SET FOR LEFT COMBINED HEEL AND MEDIAL TOE NEEDS TO BE PULLED, THE INDEX FROM 10-25 seconds AS 
    #THE DETECTED INDEX's are within that range, then these event positions can be used to pull sections from the reduced summed data set
    left_summed_data = LEFT_FSR_TOTAL
    #reduce by pulling out proper index
    index_page8 = list(range(1000,2501,1))
    
    left_summed_data_REDUCED = left_summed_data[index_page8] #THIS IS ALSO NORMALIZED BY BODY WEIGHT ALREADY SO DONT HAVE TO WORRY
    
    left_dataFrame_iterator = 0
    left_leg_FILL_DataFrame = pd.DataFrame() #define empty dataframe to which other dataframes can be concatenated to within the loop
    
    while left_dataFrame_iterator <= len(left_HS_index_array) - 1:
        LEFT_data_to_inject = left_summed_data_REDUCED[left_HS_index_array[left_dataFrame_iterator]:left_TO_index_array[left_dataFrame_iterator] + 1] #need to add 1 for some dumb reason, test in terminal
        
        #each individual set needs to be it's own dataframe that can be appended to the initial empty data frame
        left_temporary_DataFrame = pd.DataFrame({f'column{left_dataFrame_iterator}': LEFT_data_to_inject})
        #now concatenate to empty data frame w correct axis such that NaN's appear when columns of different length exist
        left_leg_FILL_DataFrame = pd.concat([left_leg_FILL_DataFrame, left_temporary_DataFrame], axis = 1)
        
        left_dataFrame_iterator = left_dataFrame_iterator + 1
        
    #now should have data frame with columns containing all cycle data from each heel on to respective toe off 
    #can transpose to get the first element of each cycle in its own column as rows turn into columns from transposition operation - then can take column mean and std for each column
    left_leg_FILL_DataFrame['mean'] = left_leg_FILL_DataFrame.mean(axis = 1)
    left_leg_FILL_DataFrame['std'] = left_leg_FILL_DataFrame.std(axis = 1)
    
    #now the final two columns in the dataFrame should contain the relevant data needed for gait cycle plotting for the left leg
    #repeat algo for right leg, then organize data for plotting
    
    ################ RIGHT LEG ALGORITHM ############@*#&^$*@&#^$(@#*$&(@*#&$(@#^)))
    right_length_iterator_case1 = 0
    right_length_iterator_case2 = 1
    
    right_event_positions = []
    
    #going to assume it will be basically impossible for HS and TO to happen at the same time
    if RHS[0] < RTO[0]: #i.e heel strike comes first for left foot
        while right_length_iterator_case1 <= len(RHS) - 1: #could use length of either, doesnt matter. Will be same length at this point 
            right_event_positions.append(RHS[right_length_iterator_case1])
            right_event_positions.append(RTO[right_length_iterator_case1])
            
            #now the even elements are the heel on's and the odd elements in the list are the toe offs
            
            right_length_iterator_case1 = right_length_iterator_case1 + 1
    elif RTO[0] < RHS[0]: #i.e to on happens first for left foot
        while right_length_iterator_case2 <= len(LTO) - 1: #this one has to be LTO since need to start at 1st index rather than 0th and will run out of space first with LTO
            right_event_positions.append(RHS[right_length_iterator_case2 - 1])
            right_event_positions.append(RTO[right_length_iterator_case2])
            
            right_length_iterator_case2 = right_length_iterator_case2 + 1
    else: #this is if they happen at the same time, which probably should never happen ever
        pass
    
    #now with the left_event_positions array, figured out how to break up into correct data sets from the initial data
    #now break up into odd and even arrays?
    #WE KNOW NOW FOR SURE THERE WILL BE AN EVEN LENGTH IN THIS ARRAY
    right_HS_index_array = right_event_positions[0::2]
    right_TO_index_array = right_event_positions[1::2] #THESE FOR SURE HAVE THE SAME LENGTH
    
    #now i think i can make a pandas data frame with the same number of columns as the length of one of either of the two arrays above
    #this is gonna be ugly as fack
    #each column needs to be its own dataframe, then can append all data frames together and will fill in NaN's in cases where not exact same length 
    #then can transpose ^T and take average and set exclude NaN's to get average of each column 
    
    #FIRST THE DATA SET FOR LEFT COMBINED HEEL AND MEDIAL TOE NEEDS TO BE PULLED, THE INDEX FROM 10-25 seconds AS 
    #THE DETECTED INDEX's are within that range, then these event positions can be used to pull sections from the reduced summed data set
    right_summed_data = RIGHT_FSR_TOTAL
    #reduce by pulling out proper index
    index_page8_1 = list(range(1000,2501,1))
    
    right_summed_data_REDUCED = right_summed_data[index_page8_1] #THIS IS ALSO NORMALIZED BY BODY WEIGHT ALREADY SO DONT HAVE TO WORRY
    
    right_dataFrame_iterator = 0
    right_leg_FILL_DataFrame = pd.DataFrame() #define empty dataframe to which other dataframes can be concatenated to within the loop
    
    while right_dataFrame_iterator <= len(right_HS_index_array) - 1:
        RIGHT_data_to_inject = right_summed_data_REDUCED[right_HS_index_array[right_dataFrame_iterator]:right_TO_index_array[right_dataFrame_iterator] + 1] #need to add 1 for some dumb reason, test in terminal
        
        #each individual set needs to be it's own dataframe that can be appended to the initial empty data frame
        right_temporary_DataFrame = pd.DataFrame({f'column{right_dataFrame_iterator}': RIGHT_data_to_inject})
        #now concatenate to empty data frame w correct axis such that NaN's appear when columns of different length exist
        right_leg_FILL_DataFrame = pd.concat([right_leg_FILL_DataFrame, right_temporary_DataFrame], axis = 1)
        
        right_dataFrame_iterator = right_dataFrame_iterator + 1
        
    #now should have data frame with columns containing all cycle data from each heel on to respective toe off 
    #can transpose to get the first element of each cycle in its own column as rows turn into columns from transposition operation - then can take column mean and std for each column
    right_leg_FILL_DataFrame['mean'] = right_leg_FILL_DataFrame.mean(axis = 1)
    right_leg_FILL_DataFrame['std'] = right_leg_FILL_DataFrame.std(axis = 1)
    
    #now organize correct data for plotting
    global left_average_GAITCYCLE
    global left_positive_STD
    global left_negative_STD
    global left_X_AXIS_FOR_ALLPLOTS
    left_average_GAITCYCLE = np.array(left_leg_FILL_DataFrame['mean'])
    left_positive_STD = left_average_GAITCYCLE + np.array(left_leg_FILL_DataFrame['std'])
    left_negative_STD = left_average_GAITCYCLE - np.array(left_leg_FILL_DataFrame['std'])
    left_X_AXIS_FOR_ALLPLOTS = np.linspace(0, 100, len(left_average_GAITCYCLE)) #this is basically 0-100% of gait cycle on the x axis for the purpose of plotting
    
    global right_average_GAITCYCLE
    global right_positive_STD
    global right_negative_STD
    global right_X_AXIS_FOR_ALLPLOTS
    right_average_GAITCYCLE = np.array(right_leg_FILL_DataFrame['mean'])
    right_positive_STD = right_average_GAITCYCLE + np.array(right_leg_FILL_DataFrame['std'])
    right_negative_STD = right_average_GAITCYCLE - np.array(right_leg_FILL_DataFrame['std'])
    right_X_AXIS_FOR_ALLPLOTS = np.linspace(0, 100, len(right_average_GAITCYCLE))
    
    ####NOW ALL DATA IS ORGANIZED INTO RESPECTIVE ARRAYS AND READY FOR PLOTTING ON PAGE 8 USING TOGGLE SWITCHES
    global refresh_GCPLOTS_button
    global p8_canvas
    global p8_toolbar
    global L_gait_cycle_button
    global L_standard_deviation_button
    global R_gait_cycle_button
    global R_standard_deviation_button
    
    global Legend1_Label_GC
    global dynamic_Label_LEFT_GC
    global dynamic_Label_RIGHT_GC
    
    
    #create plot refresh button
    def refresh_GAITCYCLE(): #in here create new instance of fresh plot
        
        global p8_canvas #so that it can be destroyed
        global p8_toolbar
        global L_gait_cycle_button
        global L_standard_deviation_button
        global R_gait_cycle_button
        global R_standard_deviation_button
        
        global Legend1_Label_GC
        global dynamic_Label_LEFT_GC
        global dynamic_Label_RIGHT_GC
        
        #now destroy the old one
        p8_canvas.get_tk_widget().destroy()
        p8_toolbar.destroy()
        #DESTROY ALL BUTTONS 
        L_gait_cycle_button.destroy()
        L_standard_deviation_button.destroy()
        
        R_gait_cycle_button.destroy()
        R_standard_deviation_button.destroy()
        
        #ALSO DESTROY THE LEGENDS
        Legend1_Label_GC.destroy()
        dynamic_Label_LEFT_GC.destroy()
        dynamic_Label_RIGHT_GC.destroy()
        
        #now create new canvas
        page8_figure = Figure(figsize = (12,6), dpi = 100)
        p8_graph_variable = page8_figure.add_subplot(111)
        p8_canvas = FigureCanvasTkAgg(page8_figure, page8)
        p8_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
        p8_graph_variable.set_xlabel('Percent Stance Phase [%]')
        p8_graph_variable.set_ylabel('Normalized Ground Reaction Force [% Body Weight]')
        p8_toolbar = NavigationToolbar2Tk(p8_canvas, page8)
        p8_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
        
        #ABOUT TO GET CRAZY IN HERE
        #UNFORTUNATELY even though the p5 plot is recreated in here, the old buttons aren't updated with this new instance of this variable
        #the only fix I know how to do is to recreate the buttons overlayed on the old ones and redefined in this function to allow for continuous re-plotting
        #should probably destroy the buttons as well as the old plot and labels before recreating
        
        #RECREATE THE BUTTON FUNCTIONS
        def L_gait_cycle_SWITCH():
    
            global L_gait_cycle_on
    
            if L_gait_cycle_on == False:
                L_gait_cycle_on = True
                L_gait_cycle_button.config(image = ON_GC)
                L_gait_cycle_button['state'] = DISABLED
                #and now plot appropriate data set
                p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_average_GAITCYCLE*100)*250/3, color = "red", linestyle = "solid")
                p8_canvas.draw()
            else:
                L_gait_cycle_button.config(image = OFF_GC)
                L_gait_cycle_on = False

        def L_standard_deviation_SWITCH():
    
            global L_standard_deviation_on
    
            if L_standard_deviation_on == False:
                L_standard_deviation_on = True
                L_standard_deviation_button.config(image = ON_GC)
                L_standard_deviation_button['state'] = DISABLED
            
                p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_positive_STD*100)*250/3, color = "red", linestyle = "dashed")
                p8_canvas.draw()
                p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_negative_STD*100)*250/3, color = "red", linestyle = "dashed")
                p8_canvas.draw()
            else:
                L_standard_deviation_button.config(image = OFF_GC)
                L_standard_deviation_on = False

        #RIGHT
        def R_gait_cycle_SWITCH():
    
            global R_gait_cycle_on
    
            if R_gait_cycle_on == False:
                R_gait_cycle_on = True
                R_gait_cycle_button.config(image = ON_GC)
                R_gait_cycle_button['state'] = DISABLED
            
                p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_average_GAITCYCLE*100)*250/3, color = "blue", linestyle = "solid")
                p8_canvas.draw()
            else:
                R_gait_cycle_button.config(image = OFF_GC)
                R_gait_cycle_on = False

        def R_standard_deviation_SWITCH():
    
            global R_standard_deviation_on
    
            if R_standard_deviation_on == False:
                R_standard_deviation_on = True
                R_standard_deviation_button.config(image = ON_GC)
                R_standard_deviation_button['state'] = DISABLED
            
                p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_positive_STD*100)*250/3, color = "blue", linestyle = "dashed")
                p8_canvas.draw()
                p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_negative_STD*100)*250/3, color = "blue", linestyle = "dashed")
                p8_canvas.draw()
            else:
                R_standard_deviation_button.config(image = OFF_GC)
                R_standard_deviation_on = False
        
        #NEED TO RECREATE THE TOGGLE SWITCH BUTTONS
        L_gait_cycle_button = Button(page8, image = OFF_GC, bd = 0, command = L_gait_cycle_SWITCH)
        L_gait_cycle_button.place(relx = 0.1, rely = 0.35, anchor = "center")

        L_standard_deviation_button = Button(page8, image = OFF_GC, bd = 0, command = L_standard_deviation_SWITCH)
        L_standard_deviation_button.place(relx = 0.1, rely = 0.45, anchor = "center")

        R_gait_cycle_button = Button(page8, image = OFF_GC, bd = 0, command = R_gait_cycle_SWITCH)
        R_gait_cycle_button.place(relx = 0.9, rely = 0.35, anchor = "center")

        R_standard_deviation_button = Button(page8, image = OFF_GC, bd = 0, command = R_standard_deviation_SWITCH)
        R_standard_deviation_button.place(relx = 0.9, rely = 0.45, anchor = "center")
        
        #now have to toggle off all 8 switches
        global L_gait_cycle_on
        global L_standard_deviation_on

        global R_gait_cycle_on
        global R_standard_deviation_on
        
        L_gait_cycle_button.config(image = OFF_GC)
        L_gait_cycle_on = False
        L_gait_cycle_button['state'] = NORMAL
        
        L_standard_deviation_button.config(image = OFF_GC)
        L_standard_deviation_on = False
        L_standard_deviation_button['state'] = NORMAL
        
        R_gait_cycle_button.config(image = OFF_GC)
        R_gait_cycle_on = False
        R_gait_cycle_button['state'] = NORMAL
        
        R_standard_deviation_button.config(image = OFF_GC)
        R_standard_deviation_on = False
        R_standard_deviation_button['state'] = NORMAL
        
        #also in here have to recreate the static and dynamic labels 
        Legend1_Label_GC = Label(page8, text = "--- STANDARD DEVIATION \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        Legend1_Label_GC.place(relx = 0.725, rely = 0.155, anchor = "w")
        
        dynamic_Label_LEFT_GC = Label(page8, text = f"LEFT ({left_leg_status_GC})", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_LEFT_GC.place(relx = 0.23, rely = 0.14, anchor = "center")
    
        dynamic_Label_RIGHT_GC = Label(page8, text = f"RIGHT ({right_leg_status_GC})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
        dynamic_Label_RIGHT_GC.place(relx = 0.23, rely = 0.16, anchor = "center")
          
        
    refresh_GCPLOTS_button = Button(page8, text = "REFRESH PLOT", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'midnight blue', command = refresh_GAITCYCLE)
    refresh_GCPLOTS_button.place(relx = 0.5, rely = 0.1, anchor = "center")
    
    
    global amputation_SIDE_GC
    global left_leg_status_GC
    global right_leg_status_GC
    global TIME_GC
    
    global L_gait_cycle_label
    global L_standard_deviation_label
    
    global R_gait_cycle_label
    global R_standard_deviation_label
    
    #HERE WANT TO PULL AMPUTATION SIDE TO CREATE CUSTOMIZED PLOT LEGENDS BASED ON THE PATIENT 
    #there are 4 cases
    
    amputation_String_GC_plots = str(patientAmputation) #need to convert list from page 2 into a string 

    if "Left" in amputation_String_GC_plots and "Right" not in amputation_String_GC_plots:
        amputation_SIDE_GC = "LEFT"
    elif "Right" in amputation_String_GC_plots and "Left" not in amputation_String_GC_plots:
        amputation_SIDE_GC = "RIGHT"
    elif "Left" in amputation_String_GC_plots and "Right" in amputation_String_GC_plots:
        amputation_SIDE_GC = "BOTH"
    else:
        amputation_SIDE_GC = "NEITHER"
    
    #CREATE INTERPOLATED ARRAY FOR TIME IN SECONDS CAUSE THAT MAKES WAY MORE SENSE THAN WHAT I WAS DOING BEFORE :()
    TIME_GC = np.interp(timeVector, [0, 2999], [0, 30]) #THIS IS THE X AXIS FOR EVERYTHING
    
    ##NOW HERE WE GENERATE PLOTS USING MATPLOTLIB LIBRARY
    page8_figure = Figure(figsize = (12,6), dpi = 100)
    p8_graph_variable = page8_figure.add_subplot(111)
    #p5_graph_variable.plot(TIME, LEFT_FSR1_NORMALIZED)
    
    #f = p5_graph_variable.plot([1,2,3], [1,2,3])
    
    p8_canvas = FigureCanvasTkAgg(page8_figure, page8)
    #p5_canvas.draw()
    p8_canvas.get_tk_widget().place(relx = 0.5, rely = 0.4, anchor = "center")
    
    #TO ADD MULTIPLE PLOTS TO SAME CHART, CAN DO ANOTHER p5_graph_variable.plot() and then must follow up with p5_canvas.draw() to add the data to the chart 
    
    #add AXIS LABELS 
    p8_graph_variable.set_xlabel('Percent Stance Phase [%]')
    p8_graph_variable.set_ylabel('Normalized Ground Reaction Force [% Body Weight]')
    #p5_graph_variable.set_title('')
    
    p8_toolbar = NavigationToolbar2Tk(p8_canvas, page8)
    p8_toolbar.place(relx = 0.33, rely = 0.66, anchor = "center")
    
    #CREATE hacked LEGEND USING LABEL I GUESS
    #define static label
    Legend1_Label_GC = Label(page8, text = "--- STANDARD DEVIATION \n ___ TOTAL", font = ('Helvetica', 10), fg = 'midnight blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    Legend1_Label_GC.place(relx = 0.725, rely = 0.155, anchor = "w")
    
    #define dynamic label
    #based on user input, this one is gonna suck
    if amputation_SIDE_GC == "LEFT":
        left_leg_status_GC = "Prosthesis"
        right_leg_status_GC = "Intact"
    elif amputation_SIDE_GC == "RIGHT":
        left_leg_status_GC = "Intact"
        right_leg_status_GC = "Prosthesis"
    elif amputation_SIDE_GC == "BOTH":
        left_leg_status_GC = "Prosthesis"
        right_leg_status_GC = "Prosthesis"
    else:
        left_leg_status_GC = "Intact"
        right_leg_status_GC = "Intact"
        
    dynamic_Label_LEFT_GC = Label(page8, text = f"LEFT ({left_leg_status_GC})", font = ('Helvetica', 12), fg = 'red4', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_LEFT_GC.place(relx = 0.23, rely = 0.14, anchor = "center")
    
    dynamic_Label_RIGHT_GC = Label(page8, text = f"RIGHT ({right_leg_status_GC})", font = ('Helvetica', 12), fg = 'blue', bg = 'ghost white', borderwidth = 2, relief = "solid")
    dynamic_Label_RIGHT_GC.place(relx = 0.23, rely = 0.16, anchor = "center")
    
    #CREATE TOGGLE SWITCHES TO DISPLAY CORRECT DATA SETS ON GRAPH (this will be hard probably)
    #using imported images overlayed on buttons for simulation of a toggle switch

    #DEFINE TOGGLE IMAGES
    ON_GC = ImageTk.PhotoImage(Image.open("images/ON.jpg"))
    OFF_GC = ImageTk.PhotoImage(Image.open("images/OFF.jpg"))

    #DEFINE BUTTON STATE BOOLEANS
    global L_gait_cycle_on
    global L_standard_deviation_on

    global R_gait_cycle_on
    global R_standard_deviation_on

    L_gait_cycle_on = False
    L_standard_deviation_on = False

    R_gait_cycle_on = False
    R_standard_deviation_on = False

    #DEFINE CALLABLE FUNCTIONS
    #LEFT
    def L_gait_cycle_SWITCH():
    
        global L_gait_cycle_on
    
        if L_gait_cycle_on == False:
            L_gait_cycle_on = True
            L_gait_cycle_button.config(image = ON_GC)
            L_gait_cycle_button['state'] = DISABLED
            #and now plot appropriate data set
            p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_average_GAITCYCLE*100)*250/3, color = "red", linestyle = "solid")
            p8_canvas.draw()
        else:
            L_gait_cycle_button.config(image = OFF_GC)
            L_gait_cycle_on = False

    def L_standard_deviation_SWITCH():
    
        global L_standard_deviation_on
    
        if L_standard_deviation_on == False:
            L_standard_deviation_on = True
            L_standard_deviation_button.config(image = ON_GC)
            L_standard_deviation_button['state'] = DISABLED
            
            p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_positive_STD*100)*250/3, color = "red", linestyle = "dashed")
            p8_canvas.draw()
            p8_graph_variable.plot(left_X_AXIS_FOR_ALLPLOTS, (left_negative_STD*100)*250/3, color = "red", linestyle = "dashed")
            p8_canvas.draw()
        else:
            L_standard_deviation_button.config(image = OFF_GC)
            L_standard_deviation_on = False

    #RIGHT
    def R_gait_cycle_SWITCH():
    
        global R_gait_cycle_on
    
        if R_gait_cycle_on == False:
            R_gait_cycle_on = True
            R_gait_cycle_button.config(image = ON_GC)
            R_gait_cycle_button['state'] = DISABLED
            
            p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_average_GAITCYCLE*100)*250/3, color = "blue", linestyle = "solid")
            p8_canvas.draw()
        else:
            R_gait_cycle_button.config(image = OFF_GC)
            R_gait_cycle_on = False

    def R_standard_deviation_SWITCH():
    
        global R_standard_deviation_on
    
        if R_standard_deviation_on == False:
            R_standard_deviation_on = True
            R_standard_deviation_button.config(image = ON_GC)
            R_standard_deviation_button['state'] = DISABLED
            
            p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_positive_STD*100)*250/3, color = "blue", linestyle = "dashed")
            p8_canvas.draw()
            p8_graph_variable.plot(right_X_AXIS_FOR_ALLPLOTS, (right_negative_STD*100)*250/3, color = "blue", linestyle = "dashed")
            p8_canvas.draw()
        else:
            R_standard_deviation_button.config(image = OFF_GC)
            R_standard_deviation_on = False


    L_gait_cycle_button = Button(page8, image = OFF_GC, bd = 0, command = L_gait_cycle_SWITCH)
    L_gait_cycle_button.place(relx = 0.1, rely = 0.35, anchor = "center")

    L_standard_deviation_button = Button(page8, image = OFF_GC, bd = 0, command = L_standard_deviation_SWITCH)
    L_standard_deviation_button.place(relx = 0.1, rely = 0.45, anchor = "center")

    R_gait_cycle_button = Button(page8, image = OFF_GC, bd = 0, command = R_gait_cycle_SWITCH)
    R_gait_cycle_button.place(relx = 0.9, rely = 0.35, anchor = "center")

    R_standard_deviation_button = Button(page8, image = OFF_GC, bd = 0, command = R_standard_deviation_SWITCH)
    R_standard_deviation_button.place(relx = 0.9, rely = 0.45, anchor = "center")

    #CREATE LABELS
    L_gait_cycle_label = Label(page8, text = "LEFT FOOT GAIT CYCLE:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    L_gait_cycle_label.place(relx = 0.1, rely = 0.3, anchor = "center")
    
    L_standard_deviation_label = Label(page8, text = "LEFT FOOT STANDARD DEVIATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    L_standard_deviation_label.place(relx = 0.1, rely = 0.4, anchor = "center")
    
    R_gait_cycle_label = Label(page8, text = "RIGHT FOOT GAIT CYCLE:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    R_gait_cycle_label.place(relx = 0.9, rely = 0.3, anchor = "center")
    
    R_standard_deviation_label = Label(page8, text = "RIGHT FOOT STANDARD DEVIATION:", font = ('Helvetica', 11, 'bold'), bg = 'gray89', fg = 'midnight blue')
    R_standard_deviation_label.place(relx = 0.9, rely = 0.4, anchor = "center")

    
gait_cycle_plots_button = Button(page8, text = "DISPLAY GAIT CYCLE PLOTS", font = ('Helvetica', 13, 'bold'), bg = 'green2', fg = 'ghost white', command = gait_cycle_function)
gait_cycle_plots_button.place(relx = 0.5, rely = 0.05, anchor = "center")
#NOW SET THIS BUTTON STATE AS DISABLED INITIALLY, HAVE IT ENABLED FROM THE PARAMETERS FUNCTION ON PAGE 7
gait_cycle_plots_button['state'] = DISABLED

#section for page3 help button
def p8HELP_FUNCTION(): #in here open up a frame that has instructions on what to do on the page
    pass

page8_HELP = Button(page8, text = "HELP", font = ('Helvetica', 13, 'bold'), bg = 'gray70', fg = 'ghost white', command = p8HELP_FUNCTION)
page8_HELP.place(relx = 0.9, rely = 0.05, anchor = "center", height = 40, width = 70)
#######################################################################################################################################################



########################################################################################################################################################
#SECTION FOR ADDING TO PAGE 9
page9Image = ImageTk.PhotoImage(Image.open("images/decisionics.png"))
page9ImageLabel = Label(page9, image = newP1_IMAGE)
page9ImageLabel.place(relx = 0.5, rely = 0.18, anchor = "center")

thankyou_label = Label(page9, text = "THANK YOU FOR USING THE GAIT ANALYSIS TOOL!", font = ('Helvetica', 20), fg = 'midnight blue', bg = 'gray89')
thankyou_label.place(relx = 0.5, rely = 0.3, anchor = "center")

#create button for clearing out patient entry page and returning back to create new patient profile
def createNewPatientFunction():

    masterNotebook.select(page1) #back to page one in case new patient in same session is also a returning patient
    
    #PAGE 1 ACTIONS
    login_Entry.delete(0, END)
    login_Entry['state'] = NORMAL

    #PAGE 2 ACTIONS
    weightEntry['state'] = NORMAL
    emailEntry['state'] = NORMAL
    genderVariable.set("Male")
    amputationOptionsSelect.selection_clear(0, END)
    heightEntry.delete(0, END)
    weightEntry.delete(0, END)
    ageEntry.delete(0, END)
    comorbidityVariable.set("NO")
    comorbidityEntry.delete('1.0', END) #THIS IS TEXT WIDGET NOT ENTRY WIDGET
    emailEntry.delete(0, END)
    prosthesisEntry.delete('1.0', END) #THIS IS TEXT WIDGET NOT ENTRY WIDGET
    occupationVariable.set("")
    activityType.set("")
    ampYearEntry.delete(0, END)
    confirmationButton['state'] = DISABLED
    p2SubmitButton['state'] = DISABLED
    check_username_button['state'] = NORMAL
    
    #PAGE 3 ACTIONS
    skipButton['state'] = NORMAL
    
    #PAGE 4 ACTIONS
    startTestButton['state'] = NORMAL
    
    #PAGE 5 ACTIONS   
    p5_canvas.get_tk_widget().destroy()
    p5_toolbar.destroy()
    LTM_button.destroy()
    LTL_button.destroy()
    LH_button.destroy()
    LTotal_button.destroy()
    RTM_button.destroy()
    RTL_button.destroy()
    RH_button.destroy()
    RTotal_button.destroy()
    Legend1_Label.destroy()
    dynamic_Label_LEFT.destroy()
    dynamic_Label_RIGHT.destroy()
    LTM_label.destroy()
    LTL_label.destroy()
    LH_label.destroy()
    LTotal_label.destroy()
    RTM_label.destroy()
    RTL_label.destroy()
    RH_label.destroy()
    RTotal_label.destroy()
    submitAmputationSIDEButton['state'] = NORMAL
    refreshPlot_button.destroy()
    select_sensor_label.destroy()
    left_sensor_list.destroy()
    left_confirm_sensor_button.destroy()
    right_sensor_list.destroy()
    right_confirm_sensor_button.destroy()
    
    #page 6 actions
    p6_canvas.get_tk_widget().destroy()
    p6_toolbar.destroy()
    L_vertical_button.destroy()
    L_horizontal_button.destroy()
    L_Total_button.destroy()
    R_vertical_button.destroy()
    R_horizontal_button.destroy()
    R_Total_button.destroy()
    Legend1_Label_IMU.destroy()
    dynamic_Label_LEFT_IMU.destroy()
    dynamic_Label_RIGHT_IMU.destroy()
    L_vertical_label.destroy()
    L_horizontal_label.destroy()
    L_Total_label.destroy()
    R_vertical_label.destroy()
    R_horizontal_label.destroy()
    R_Total_label.destroy()
    acceleration_plot_button['state'] = NORMAL
    refresh_Acceleration_button.destroy()
    
    #page 7 actions
    parameters_label.destroy()
    left_leg_label.destroy()
    right_leg_label.destroy()
    normative_data_label.destroy()
    step_time_label.destroy()
    step_time_units_label.destroy()
    cycle_time_label.destroy()
    cycle_time_units_label.destroy()
    cadence_label.destroy()
    cadence_units_label.destroy()
    swing_time_label.destroy()
    swing_time_units_label.destroy()
    stance_time_label.destroy()
    stance_time_units_label.destroy()
    single_support_time_label.destroy()
    single_support_time_units_label.destroy()
    double_support_time_label.destroy()
    double_support_time_units_label.destroy()
    stance_symmetry_label.destroy()
    swing_symmetry_label.destroy()
    step_time_left_measured.destroy()
    cycle_time_left_measured.destroy()
    cadence_left_measured.destroy()
    swing_time_left_measured.destroy()
    stance_time_left_measured.destroy()
    single_support_left_measured.destroy()
    double_support_left_measured.destroy()
    stance_symmetry_measured.destroy()
    cycle_symmetry_measured.destroy()
    step_time_right_measured.destroy()
    cycle_time_right_measured.destroy()
    cadence_right_measured.destroy()
    swing_time_right_measured.destroy()
    stance_time_right_measured.destroy()
    single_support_right_measured.destroy()
    double_support_right_measured.destroy()
    normative_step_time.destroy()
    normative_cycle_time.destroy()
    normative_cadence.destroy()
    normative_swing_time.destroy()
    normative_stance_time.destroy()
    normative_single_time.destroy()
    normative_double_time.destroy()
    gait_parameters_button['state'] = DISABLED
    
    #page 8 actions
    p8_canvas.get_tk_widget().destroy()
    p8_toolbar.destroy()
    L_gait_cycle_button.destroy()
    L_standard_deviation_button.destroy()
    R_gait_cycle_button.destroy()
    R_standard_deviation_button.destroy()
    Legend1_Label_GC.destroy()
    dynamic_Label_LEFT_GC.destroy()
    dynamic_Label_RIGHT_GC.destroy()
    L_gait_cycle_label.destroy()
    L_standard_deviation_label.destroy()
    R_gait_cycle_label.destroy()
    R_standard_deviation_label.destroy()
    gait_cycle_plots_button['state'] = NORMAL
    refresh_GCPLOTS_button.destroy()
    

#ADD IN PDF REPORT GENERATION BUTTON/FUNCTION
def generate_report_function():
    
    global pdf #this needs to be global for the table generation function to be callable 
    
    #now build up PDF and combine two files then delete the old ones lol
    #load in date/time and username to print on PDF
    date_forPDF = dt_string
    #now load in username - need to make sure it accounts for new and returning user
    new_user_PDF = emailEntry.get()
    returning_user_PDF = login_Entry.get()

    if len(new_user_PDF) > 0 and len(returning_user_PDF) == 0:
        name_for_PDF = new_user_PDF

    elif len(returning_user_PDF) > 0 and len(new_user_PDF) == 0:
        name_for_PDF = returning_user_PDF
        
    
    welcome_string = f"{name_for_PDF} Gait Analytics Client Report"

    pdf = FPDF('P', 'mm', 'Letter')

    pdf.add_page()
    pdf.set_font('Helvetica', 'B', 12)
    DH = pdf.h
    pdf.set_y(DH/3)

    pdf.cell(0, 5, welcome_string, ln = True, align = 'C')

    pdf.set_font('Helvetica', 'B', 10)
    pdf.cell(0, 8, date_forPDF, ln = True, align = 'C')

    pdf.add_page() #this is data table page
    
    #NOW NEED TO FORMAT DATA CORRECTLY TO CAN BE PUT IN TABLE
    #this structure should be a list of lists of strings...
    data_for_table_PDF = [["Parameters", f"Left Leg ({left_leg_status})", f"Right Leg ({right_leg_status})", "Normative Data"],
                          ["Step Time (+/- SD) (s):", f"{LEFT_STEP_TIME_TEMPORAL} (+/- {LEFT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION})", f"{RIGHT_STEP_TIME_TEMPORAL} (+/- {RIGHT_STEP_TIME_TEMPORAL_STANDARD_DEVIATION})", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_step']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_step_STD']})"],
                          ["Cycle Time (+/- SD) (s):", f"{GAIT_CYCLE_LEFT_TEMPORAL} (+/- {GAIT_CYCLE_LEFT_TEMPORAL_STANDARD_DEVIATION})", f"{GAIT_CYCLE_RIGHT_TEMPORAL} (+/- {GAIT_CYCLE_RIGHT_TEMPORAL_STANDARD_DEVIATION})", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cycle']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cycle_STD']})"],
                          ["Cadence (+/- SD) (cycle/min):", f"{LEFT_CADENCE_TEMPORAL} (+/- {LEFT_CADENCE_TEMPORAL_STANDARD_DEVIATION})", f"{RIGHT_CADENCE_TEMPORAL} (+/- {RIGHT_CADENCE_TEMPORAL_STANDARD_DEVIATION})", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cadence']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_cadence_STD']})"],
                          ["Swing Time (+/- SD) / % Cycle (s):", f"{SWING_PHASE_LEFT_TEMPORAL} (+/- {SWING_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {SWING_PHASE_LEFT_TEMPORAL_PERCENTAGE}%", f"{SWING_PHASE_RIGHT_TEMPORAL} (+/- {SWING_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {SWING_PHASE_RIGHT_TEMPORAL_PERCENTAGE}%", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_swing_%']}%"],
                          ["Stance Time (+/- SD) / % Cycle (s):", f"{STANCE_PHASE_LEFT_TEMPORAL} (+/- {STANCE_PHASE_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {STANCE_PHASE_LEFT_TEMPORAL_PERCENTAGE}%", f"{STANCE_PHASE_RIGHT_TEMPORAL} (+/- {STANCE_PHASE_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {STANCE_PHASE_RIGHT_TEMPORAL_PERCENTAGE}%", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_stance_%']}%"],
                          ["Single Support Time (+/- SD) / % Cycle (s):", f"{SINGLE_SUPPORT_LEFT_TEMPORAL} (+/- {SINGLE_SUPPORT_LEFT_TEMPORAL_STANDARD_DEVIATION}) / {SINGLE_SUPPORT_LEFT_TEMPORAL_PERCENTAGE}%", f"{SINGLE_SUPPORT_RIGHT_TEMPORAL} (+/- {SINGLE_SUPPORT_RIGHT_TEMPORAL_STANDARD_DEVIATION}) / {SINGLE_SUPPORT_RIGHT_TEMPORAL_PERCENTAGE}%", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_single_%']}%"],
                          ["Double Support Time (+/- SD) / % Cycle (s):", f"{LEFT_DOUBLE_SUPPORT_TEMPORAL} (+/- {LEFT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION}) / {LEFT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE}%", f"{RIGHT_DOUBLE_SUPPORT_TEMPORAL} (+/- {RIGHT_DOUBLE_SUPPORT_TEMPORAL_STANDARD_DEVIATION}) / {RIGHT_DOUBLE_SUPPORT_TEMPORAL_PERCENTAGE}%", f"{normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double']} (+/- {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double_STD']}) / {normative_data_dictionary[f'{identifier_AGE}_{identifier_GENDER}_double_%']}%"], 
                          ]
    
    create_table(table_data = data_for_table_PDF, title=f'{name_for_PDF} Temporal Parameters - {date_forPDF}', cell_width='even')
    pdf.ln()
    
    #PRINT OUT THE STANCE SYMMETRY AND CYCLE SYMMETRY IN A SEPARATE PART FROM THE TABLE
    pdf.cell(0, 5, f'Stance Symmetry Ratio (Robinson Index): {STANCE_SYMMETRY_TEMPORAL}', ln = True, align = 'L')
    pdf.ln()
    pdf.cell(0, 5, f'Cycle Symmetry Ratio (Robinson Index): {CYCLE_SYMMETRY_TEMPORAL}', ln = True, align = 'L')
    
    #OUTPUT FIRST PDF TO FILES as temp_tables and second as temp_graphs
    pdf.output(f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_TABLES.pdf')
    
    #NOW BUILD UP THE PLOTS PDF AND SAVE AS TEMP_GRAPHS
    #ADD IN NEW DEPENDENCIES
    with PdfPages(f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_PLOTS.pdf') as export_pdf:
        #generate first figure
        #figure 0 = both legs plots, figure 1 = left leg plot + std, figure 2 = right leg plot + std
        plt.figure(0)
        plt.title('Left Average Gait Cycle & Standard Deviation')
        plt.xlabel('Percent Stance Phase [%]')
        plt.ylabel('Normalized Ground Reaction Force [% Body Weight]')
        plt.plot(left_X_AXIS_FOR_ALLPLOTS, (left_average_GAITCYCLE*100)*250/3, color = "red", linestyle = "solid")
        plt.plot(left_X_AXIS_FOR_ALLPLOTS, (left_positive_STD*100)*250/3, color = "red", linestyle = "dashed")
        plt.plot(left_X_AXIS_FOR_ALLPLOTS, (left_negative_STD*100)*250/3, color = "red", linestyle = "dashed")
        plt.grid(True)
        export_pdf.savefig()
        plt.close()
        
        plt.figure(1)
        plt.title('Right Average Gait Cycle & Standard Deviation')
        plt.xlabel('Percent Stance Phase [%]')
        plt.ylabel('Normalized Ground Reaction Force [% Body Weight]')
        plt.plot(right_X_AXIS_FOR_ALLPLOTS, (right_average_GAITCYCLE*100)*250/3, color = "blue", linestyle = "solid")
        plt.plot(right_X_AXIS_FOR_ALLPLOTS, (right_positive_STD*100)*250/3, color = "blue", linestyle = "dashed")
        plt.plot(right_X_AXIS_FOR_ALLPLOTS, (right_negative_STD*100)*250/3, color = "blue", linestyle = "dashed")
        plt.grid(True)
        export_pdf.savefig()
        plt.close()
        
        plt.figure(2)
        plt.title('Overlayed Average Gait Cycle Plots')
        plt.xlabel('Percent Stance Phase [%]')
        plt.ylabel('Normalized Ground Reaction Force [% Body Weight]')
        plt.plot(left_X_AXIS_FOR_ALLPLOTS, (left_average_GAITCYCLE*100)*250/3, color = "red", linestyle = "solid")
        plt.plot(right_X_AXIS_FOR_ALLPLOTS, (right_average_GAITCYCLE*100)*250/3, color = "blue", linestyle = "solid")
        plt.grid(True)
        export_pdf.savefig()
        plt.close()
        
    
    #NOW THAT PLOT PDF GENERATED CAN MERGE THE TWO AND THEN DELETE THE TEMPS
    pdfs_toMerge = [f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_TABLES.pdf', f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_PLOTS.pdf']
    merger = PdfMerger()
    
    for pdf in pdfs_toMerge:
        merger.append(pdf)
        
    merger.write(f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_{date_time}_Client_Test_Report.pdf')
    merger.close()
    
    #NOW CAN DELETE THE INDIVIDUAL TEMPORARY FILES USING THE OS LIB
    os.remove(f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_TABLES.pdf')
    os.remove(f'{name_for_PDF}_UserData/{name_for_PDF}_TestReports/{name_for_PDF}_TEMP_PLOTS.pdf')
    
    #THIS COMES AT END OF FUNCTION
    #MAKE SURE TO ADD IN LABEL THAT SAYS REPORT GENERATED SUCCESSFULLY 
    report_label = Label(page9, text = "REPORT GENERATED SUCCESSFULLY", font = ('Helvetica', 35), bg = 'gray89', fg = 'green2')
    report_label.place(relx = 0.5, rely = 0.62, anchor = "center")
    root.update()
    time.sleep(4)
    report_label.destroy()
    root.update()

generate_report = Button(page9, text = "GENERATE CLIENT REPORT", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = generate_report_function)
generate_report.place(relx = 0.5, rely = 0.38, anchor = "center", height = 40, width = 250)

def areyousure_function1():
    answer1 = askyesno(title = "QUIT CONFIRMATION", message = "Are you sure you want to quit?")
    #askyesno.configure(background = 'gray89')
    
    if answer1 == True:
        root.quit()
        

def areyousure_function2():
    answer2 = askyesno(title = "ADD NEW PATIENT CONFIRMATION", message = "Are you sure you would like to add a new patient? If so, please leave the devices powered on to avoid re-calibration.")
    
    if answer2 == True:
        createNewPatientFunction()
          
newPatientButton = Button(page9, text = "ADD NEW PATIENT", font = ('Helvetica', 13, 'bold'), bg = 'midnight blue', fg = 'ghost white', command = areyousure_function2)
newPatientButton.place(relx = 0.5, rely = 0.46, anchor = "center", height = 40, width = 180)

#EXIT PROGRAM BUTTON
ThankYouButton = Button(page9, text = "EXIT PROGRAM", command = areyousure_function1, bg = 'gray70', font = ('Helvetica', 13, 'bold'), fg = 'midnight blue')
ThankYouButton.place(relx = 0.5, rely = 0.54, anchor = "center", height = 40, width = 180)

#&*****^^^^^^^^^^^&&&&&&&&&&&&&&&&&&&&&*&&&&&&&&&&&&&&&&&&&&&&&&&*******&#%@@@@@@@@@^^^^^^^^^^^^^^^@@@@@@@@@@@@@@@@@@@@
#fack sakes alright, here going to define the table creation function to be called on in the PDF generation function
def create_table(table_data, title='', data_size = 10, title_size=12, align_data='L', align_header='L', cell_width='even', x_start='x_default',emphasize_data=[], emphasize_style=None, emphasize_color=(0,0,0)):
    """
    table_data: 
                list of lists with first element being list of headers
    title: 
                (Optional) title of table (optional)
    data_size: 
                the font size of table data
    title_size: 
                the font size fo the title of the table
    align_data: 
                align table data
                L = left align
                C = center align
                R = right align
    align_header: 
                align table data
                L = left align
                C = center align
                R = right align
    cell_width: 
                even: evenly distribute cell/column width
                uneven: base cell size on lenght of cell/column items
                int: int value for width of each cell/column
                list of ints: list equal to number of columns with the widht of each cell / column
    x_start: 
                where the left edge of table should start
    emphasize_data:  
                which data elements are to be emphasized - pass as list 
                emphasize_style: the font style you want emphaized data to take
                emphasize_color: emphasize color (if other than black) 
    
    """
    default_style = pdf.font_style
    if emphasize_style == None:
        emphasize_style = default_style
    # default_font = pdf.font_family
    # default_size = pdf.font_size_pt
    # default_style = pdf.font_style
    # default_color = pdf.color # This does not work

    # Get Width of Columns
    def get_col_widths():
        col_width = cell_width
        if col_width == 'even':
            col_width = pdf.epw / len(data[0]) - 1  # distribute content evenly   # epw = effective page width (width of page not including margins)
        elif col_width == 'uneven':
            col_widths = []

            # searching through columns for largest sized cell (not rows but cols)
            for col in range(len(table_data[0])): # for every row
                longest = 0 
                for row in range(len(table_data)):
                    cell_value = str(table_data[row][col])
                    value_length = pdf.get_string_width(cell_value)
                    if value_length > longest:
                        longest = value_length
                col_widths.append(longest + 4) # add 4 for padding
            col_width = col_widths



                    ### compare columns 

        elif isinstance(cell_width, list):
            col_width = cell_width  # TODO: convert all items in list to int        
        else:
            # TODO: Add try catch
            col_width = int(col_width)
        return col_width

    # Convert dict to lol
    # Why? because i built it with lol first and added dict func after
    # Is there performance differences?
    if isinstance(table_data, dict):
        header = [key for key in table_data]
        data = []
        for key in table_data:
            value = table_data[key]
            data.append(value)
        # need to zip so data is in correct format (first, second, third --> not first, first, first)
        data = [list(a) for a in zip(*data)]

    else:
        header = table_data[0]
        data = table_data[1:]

    line_height = pdf.font_size * 2.5

    col_width = get_col_widths()
    pdf.set_font(size=title_size)

    # Get starting position of x
    # Determin width of table to get x starting point for centred table
    if x_start == 'C':
        table_width = 0
        if isinstance(col_width, list):
            for width in col_width:
                table_width += width
        else: # need to multiply cell width by number of cells to get table width 
            table_width = col_width * len(table_data[0])
        # Get x start by subtracting table width from pdf width and divide by 2 (margins)
        margin_width = pdf.w - table_width
        # TODO: Check if table_width is larger than pdf width

        center_table = margin_width / 2 # only want width of left margin not both
        x_start = center_table
        pdf.set_x(x_start)
    elif isinstance(x_start, int):
        pdf.set_x(x_start)
    elif x_start == 'x_default':
        x_start = pdf.set_x(pdf.l_margin)


    # TABLE CREATION #

    # add title
    if title != '':
        pdf.multi_cell(0, line_height, title, border=0, align='j', ln=3, max_line_height=pdf.font_size)
        pdf.ln(line_height) # move cursor back to the left margin

    pdf.set_font(size=data_size)
    # add header
    y1 = pdf.get_y()
    if x_start:
        x_left = x_start
    else:
        x_left = pdf.get_x()
    x_right = pdf.epw + x_left
    if  not isinstance(col_width, list):
        if x_start:
            pdf.set_x(x_start)
        for datum in header:
            pdf.multi_cell(col_width, line_height, datum, border=0, align=align_header, ln=3, max_line_height=pdf.font_size)
            x_right = pdf.get_x()
        pdf.ln(line_height) # move cursor back to the left margin
        y2 = pdf.get_y()
        pdf.line(x_left,y1,x_right,y1)
        pdf.line(x_left,y2,x_right,y2)

        for row in data:
            if x_start: # not sure if I need this
                pdf.set_x(x_start)
            for datum in row:
                if datum in emphasize_data:
                    pdf.set_text_color(*emphasize_color)
                    pdf.set_font(style=emphasize_style)
                    pdf.multi_cell(col_width, line_height, datum, border=0, align=align_data, ln=3, max_line_height=pdf.font_size)
                    pdf.set_text_color(0,0,0)
                    pdf.set_font(style=default_style)
                else:
                    pdf.multi_cell(col_width, line_height, datum, border=0, align=align_data, ln=3, max_line_height=pdf.font_size) # ln = 3 - move cursor to right with same vertical offset # this uses an object named pdf
            pdf.ln(line_height) # move cursor back to the left margin
    
    else:
        if x_start:
            pdf.set_x(x_start)
        for i in range(len(header)):
            datum = header[i]
            pdf.multi_cell(col_width[i], line_height, datum, border=0, align=align_header, ln=3, max_line_height=pdf.font_size)
            x_right = pdf.get_x()
        pdf.ln(line_height) # move cursor back to the left margin
        y2 = pdf.get_y()
        pdf.line(x_left,y1,x_right,y1)
        pdf.line(x_left,y2,x_right,y2)


        for i in range(len(data)):
            if x_start:
                pdf.set_x(x_start)
            row = data[i]
            for i in range(len(row)):
                datum = row[i]
                if not isinstance(datum, str):
                    datum = str(datum)
                adjusted_col_width = col_width[i]
                if datum in emphasize_data:
                    pdf.set_text_color(*emphasize_color)
                    pdf.set_font(style=emphasize_style)
                    pdf.multi_cell(adjusted_col_width, line_height, datum, border=0, align=align_data, ln=3, max_line_height=pdf.font_size)
                    pdf.set_text_color(0,0,0)
                    pdf.set_font(style=default_style)
                else:
                    pdf.multi_cell(adjusted_col_width, line_height, datum, border=0, align=align_data, ln=3, max_line_height=pdf.font_size) # ln = 3 - move cursor to right with same vertical offset # this uses an object named pdf
            pdf.ln(line_height) # move cursor back to the left margin
    y3 = pdf.get_y()
    pdf.line(x_left,y3,x_right,y3)
#######################################################################################################################################################



root.mainloop() #keeps the program looping, otherwise code will only run once